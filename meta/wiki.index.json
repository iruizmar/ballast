{
  "ownKey": "wiki",
  "childrenPages": {"wiki": {
    "ownKey": "wiki",
    "childrenPages": {
      "feature-comparison": {
        "ownKey": "feature-comparison",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "feature-comparison",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/feature-comparison"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "roadmap",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/roadmap"
          },
          "previous": {
            "path": "wiki/examples",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "kamp-kit",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/examples/kamp-kit"
          },
          "description": "",
          "title": "Feature Comparison",
          "content": "<h2 id=\"feature-summary\"><a href=\"#feature-summary\" id=\"feature-summary\" class=\"anchor\"><\/a>Feature Summary<\/h2>\n<p>See table below for a comparison of features or names in Ballast vs other popular MVI libraries:<\/p>\n<table>\n<thead>\n<tr><th>MVI Feature<\/th><th>Ballast<\/th><th><a href=\"https://github.com/reduxjs/redux\">Redux<\/a><\/th><th><a href=\"https://github.com/orbit-mvi/orbit-mvi\">Orbit<\/a><\/th><th><a href=\"https://github.com/arkivanov/MVIKotlin\">MVIKotlin<\/a><\/th><th><a href=\"https://github.com/uniflow-kt/uniflow-kt\">Uniflow-kt<\/a><\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>General Philosophy<\/td><td>Opinionated Application State Management framework for all KMP targets<\/td><td>Lightweight JS UI State Management library, with many official and unofficial extensions<\/td><td>Fully-featured, low-profile UI MVI framework for Android<\/td><td>Redux implementation in Kotlin for Android<\/td><td> <\/td><\/tr>\n<tr><td>MVI Style**<\/td><td>Redux-style discrete Inputs with MVVM+ style DSL<\/td><td>Redux<\/td><td>MVVM+<\/td><td>Redux<\/td><td>MVVM+<\/td><\/tr>\n<tr><td>Kotlin Multiplatform Support<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><\/tr>\n<tr><td>Reactive State<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>vm.observeStates()<\/code><\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> <code>store.subscribe()<\/code> or 3rd-party libraries<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>container.stateFlow<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>store.states(Observer&lt;State&gt;)<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>onStates(viewModel) { }<\/code><\/td><\/tr>\n<tr><td>Get State Snapshot<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>vm.observeStates().value<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>store.getState()<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>container.stateFlow.value<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><\/tr>\n<tr><td>State Immutability<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Built-in with Kotlin data class<\/td><td><i class=\"fas fa-check\" style=\"color: purple\"><\/i> Requires Redux Toolkit w/ Immer<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Built-in with Kotlin data class<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Built-in with Kotlin data class<\/td><\/tr>\n<tr><td>Update State<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>updateState { }<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Reducers<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>reduce { }<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>Reducer&lt;State, Intent&gt;<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>setState { }<\/code><\/td><\/tr>\n<tr><td>Restore Saved States<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state\">Saved State module<\/a><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Built-in<\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Manual restoration with Essenty<\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Only supports Android <code>SavedStateHandle<\/code><\/td><\/tr>\n<tr><td>Lifecycle Support<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Controlled by CoroutineScope<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Controlled by Android ViewModel<\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Manual control with Essenty/Binder utilities<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Controlled by Android ViewModel<\/td><\/tr>\n<tr><td>Automatic View-Binding<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> Views observe State directly<\/td><td><i class=\"fas fa-check\" style=\"color: purple\"><\/i> Integrates very well with React<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> Views observe State directly<\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Optional <code>MviView<\/code> utility<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> Views observe State directly<\/td><\/tr>\n<tr><td>Non-UI State Management<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Repository module<\/a><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><\/tr>\n<tr><td>Create Intent<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Input sealed subclass constructor<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> &quot;actionCreators&quot; functions<\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Implicit, <code>fun vmAction() = intent { }<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Input sealed subclass constructor<\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Implicit, <code>fun vmAction = action { }<\/code><\/td><\/tr>\n<tr><td>Send Intent to VM<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>vm.send(Input)<\/code>/<code>vm.trySend(Input)<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>store.dispatch()<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Directly call VM function<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>store.accept(Intent)<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Directly call VM function<\/td><\/tr>\n<tr><td>Async Foreground Computation<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Built-in with Coroutines<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Built-in with Coroutines<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Built-in with Coroutines<\/td><\/tr>\n<tr><td>Async Background Computation<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>sideJob(key) { }<\/code><\/td><td><i class=\"fas fa-check\" style=\"color: purple\"><\/i> &quot;Thunk&quot; middleware<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>repeatOnSubscription { }<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Executors+Messages<\/td><td><i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Background work launched directly in Android viewModelScope. <code>onFlow<\/code> utility for processing Flows<\/td><\/tr>\n<tr><td>Send one-off Notifications<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>postEvent()<\/code><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>postSideEffect()<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> publish(Label)<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>sendEvent()<\/code><\/td><\/tr>\n<tr><td>React to one-off Notifications<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>vm.attachEventHandler(EventHandler)<\/code><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>container.sideEffectFlow.collect { }<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>store.labels(Observer&lt;Label&gt;)<\/code><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <code>onEvents(viewModel) { }<\/code><\/td><\/tr>\n<tr><td>Opinionated structure<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-check\" style=\"color: purple\"><\/i> <code>createSlice()<\/code> in Redux Toolkit defines an opinionated structure<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> Intentionally unopinionated. &quot;MVI without the baggage. It's so simple we think of it as MVVM+&quot;<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> Intentionally unopinionated<\/td><\/tr>\n<tr><td>Reduced boilerplate<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Templates/scaffolds available in <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Official IntelliJ Plugin<\/a><\/td><td><i class=\"fas fa-check\" style=\"color: purple\"><\/i> <code>createSlice()<\/code> in Redux Toolkit reduces boilerplate<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> The whole framework was created to reduce boilerplate<\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> The whole framework was created to reduce boilerplate<\/td><\/tr>\n<tr><td>Time-travel Debugging<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Included in <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">IntelliJ Plugin<\/a><\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <a href=\"https://github.com/reduxjs/redux-devtools\">Official Browser Extension<\/a><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <a href=\"https://arkivanov.github.io/MVIKotlin/time_travel.html\">Official IntelliJ Plugin<\/a><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><\/tr>\n<tr><td>Testing Framework<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-test\">Official testing library<\/a><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <a href=\"https://orbit-mvi.org/Test/overview/\">Official testing library<\/a><\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><\/tr>\n<tr><td>Automatic Logging<\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-ban\" style=\"color: red\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><td><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> <\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>For a more in-depth comparison of Android/Kotlin MVI libraries (that doesn't include Ballast), see <a href=\"https://appmattus.medium.com/top-android-mvi-libraries-in-2021-de1afe890f27\">this article<\/a>\nfrom one of the developers of Orbit MVI.<\/p>\n<p><i class=\"fas fa-check-double\" style=\"color: green\"><\/i> Fully Officially supported  \n<i class=\"fas fa-check\" style=\"color: purple\"><\/i> Fully supported by 3rd-party  \n<i class=\"fas fa-minus-circle\" style=\"color: #ebc634\"><\/i> Partially supported  \n<i class=\"fas fa-ban\" style=\"color: red\"><\/i> Not supported  <\/p>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>**: MVI Style refers to the general API of the library: Redux-style sends discrete objects to the library and uses some\nkind of transformer class to split out the objects into discrete streams for each input type. Additionally, a true Redux\nstyle only transforms state, with mapper functions receiving the current state and returning the updated state,\ntypically called a <code>reducer<\/code> (<code>(State, Input)-&gt;State<\/code>).<\/p>\n<p>The MVVM+ style discards the discrete input classes, and instead offers helper functions within the ViewModel to\ntranslate function calls on the ViewModel into lambdas that are processed in the expected MVI manner. MVVM+ typically\noffers a richer API, more functionality, and reduced boilerplate, but makes it less obvious what's actually going on\nwithin the library.<\/p>\n  <\/div>\n<\/article>\n"
        }]
      },
      "examples": {
        "ownKey": "examples",
        "childrenPages": {
          "kitchensink": {
            "ownKey": "kitchensink",
            "ownPages": [{
              "reference": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "kitchensink",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/kitchensink"
              },
              "next": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "kamp-kit",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/kamp-kit"
              },
              "previous": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "bgg-api",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/bgg-api"
              },
              "description": "",
              "title": "Kitchen Sink",
              "content": "<h1 id=\"kitchen-sink\"><a href=\"#kitchen-sink\" id=\"kitchen-sink\" class=\"anchor\"><\/a>Kitchen Sink<\/h1>\n<p>The &quot;Kitchen Sink&quot; example demonstrates the usage of all of Ballasts core APIs. It is most useful when viewed from the\n<a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a>.<\/p>\n<div id=\"example_kitchen_sink\"><\/div>\n<br><br>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>Pro Tip: Open your <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a> with this page open to see all Ballast activity in real-time, or\njust read the browser's Console logs.<\/p>\n  <\/div>\n<\/article>\n"
            }]
          },
          "bgg-api": {
            "ownKey": "bgg-api",
            "ownPages": [{
              "reference": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "bgg-api",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/bgg-api"
              },
              "next": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "kitchensink",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/kitchensink"
              },
              "previous": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "scorekeeper",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/scorekeeper"
              },
              "description": "",
              "title": "API Call and Cache",
              "content": "<h1 id=\"api-call-and-cache\"><a href=\"#api-call-and-cache\" id=\"api-call-and-cache\" class=\"anchor\"><\/a>API Call and Cache<\/h1>\n<p>This example shows how to make and cache API calls with <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Ballast Repository<\/a>. It demonstrates fetching\nfrom the <a href=\"https://boardgamegeek.com/\">BoardGameGeek<\/a> <a href=\"https://boardgamegeek.com/wiki/page/BGG_XML_API2\">XML API v2<\/a>** and caching the response in-memory in the <code>BallastRepository<\/code>. When fetching\na HotList, the cached response will be returned, unless &quot;Force Refresh&quot; is checked or the selected hotlist type has\nchanged.<\/p>\n<p>How to use:<\/p>\n<ul>\n<li>Select a &quot;HotList Type&quot; from the dropdown menu<\/li>\n<li>Hit &quot;Fetch HotList&quot; to request the API response from the Repository, which will determine whether to actually hit the\nAPI or just return the cached value.<\/li>\n<li>You can force the API to called again by having &quot;Force Refresh&quot; checked when you hit &quot;Fetch HotList&quot;. Alternatively,\nif you fetched data from one hotlist type (say Board Games), then change to another type (like Video Games), then the\nlist will also be refreshed, even if &quot;Force Refresh&quot; is not checked.<\/li>\n<\/ul>\n<div id=\"example_bgg\"><\/div>\n<br><br>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>Pro Tip: Open your <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a> with this page open to see all Ballast activity in real-time, or\njust read the browser's Console logs.<\/p>\n  <\/div>\n<\/article>\n<article class=\"message is-danger\">\n\n  <div class=\"message-body\">\n  <p><strong>Disclaimer<\/strong>: Because of CORS restrictions it is not possible to hit the BGG API directly, so the responses have been\ncached in this documentation site's domain. This site is not updated on any regular schedule so the data will definitely\nout-out-date. These cached responses are for demonstration purposes ONLY, and BGG will always remain the full owner of\nthe API responses and all data/images within it.<\/p>\n  <\/div>\n<\/article>\n"
            }]
          },
          "kamp-kit": {
            "ownKey": "kamp-kit",
            "ownPages": [{
              "reference": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "kamp-kit",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/kamp-kit"
              },
              "next": {
                "path": "wiki",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "feature-comparison",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/feature-comparison"
              },
              "previous": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "kitchensink",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/kitchensink"
              },
              "description": "",
              "title": "KaMPKit",
              "content": "<h1 id=\"kampkit\"><a href=\"#kampkit\" id=\"kampkit\" class=\"anchor\"><\/a>KaMPKit<\/h1>\n<p>In addition to the other examples, there's also an example using Ballast in a more real-world Android/iOS KMM\napplication with <a href=\"https://github.com/copper-leaf/KaMPKit-ballast\">KaMPKit-ballast<\/a>. This repo is a fork of <a href=\"https://github.com/touchlab/KaMPKit\">Touchlab's KaMPKit repo<\/a>, but the ViewModel and\nRepository classes have been replaced with Ballast.<\/p>\n"
            }]
          },
          "counter": {
            "ownKey": "counter",
            "ownPages": [{
              "reference": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "counter",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/counter"
              },
              "next": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "scorekeeper",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/scorekeeper"
              },
              "previous": {
                "path": "wiki",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "examples",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples"
              },
              "description": "",
              "title": "Simple Counter",
              "content": "<h1 id=\"simple-counter\"><a href=\"#simple-counter\" id=\"simple-counter\" class=\"anchor\"><\/a>Simple Counter<\/h1>\n<p>This example is just a simple counter to demonstrate the bare basics of sending Inputs and updating the ViewModel State.<\/p>\n<div id=\"example_counter\"><\/div>\n<br><br>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>Pro Tip: Open your <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a> with this page open to see all Ballast activity in real-time, or\njust read the browser's Console logs.<\/p>\n  <\/div>\n<\/article>\n"
            }]
          },
          "scorekeeper": {
            "ownKey": "scorekeeper",
            "ownPages": [{
              "reference": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "scorekeeper",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/scorekeeper"
              },
              "next": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "bgg-api",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/bgg-api"
              },
              "previous": {
                "path": "wiki/examples",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "counter",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples/counter"
              },
              "description": "",
              "title": "Scorekeeper",
              "content": "<h1 id=\"scorekeeper\"><a href=\"#scorekeeper\" id=\"scorekeeper\" class=\"anchor\"><\/a>Scorekeeper<\/h1>\n<p>The ScoreKeeper is a more complex version of a simple counter. It allows one to add/remove names from a list, and\nchange the score of each player individually.<\/p>\n<p>How to use:<\/p>\n<ul>\n<li>Use the form field to enter one or more player names. Names must be unique. Players can be removed from the game by\nclicking the &quot;X&quot; button on their card.<\/li>\n<li>Click on a player card to select or deselect that player. Hit the numbered buttons below the list to increase/decrease\nthe score of all selected players' scores by that amount.<\/li>\n<li>Scores are set temporarily to help you see how much you are adding in a single &quot;move&quot;. After 5 seconds, the temporary\nscores will be &quot;committed&quot; and their total values updated accordingly. Alternatively, you may click on an individual\nplayer's score to commit it immediately.<\/li>\n<li>Player scores will be saved to your browser's LocalStorage with every change, and restored when reloading this page\nusing the <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state\">Saved State module<\/a><\/li>\n<\/ul>\n<div id=\"example_scorekeeper\"><\/div>\n<br><br>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>Pro Tip: Open your <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a> with this page open to see all Ballast activity in real-time, or\njust read the browser's Console logs.<\/p>\n  <\/div>\n<\/article>\n"
            }]
          }
        },
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "examples",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/examples"
          },
          "next": {
            "path": "wiki/examples",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "counter",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/examples/counter"
          },
          "previous": {
            "path": "wiki/modules",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "ballast-test",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-test"
          },
          "description": "",
          "title": "Examples",
          "content": "<h1 id=\"examples\"><a href=\"#examples\" id=\"examples\" class=\"anchor\"><\/a>Examples<\/h1>\n<ul>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/counter\">Simple Counter<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/scorekeeper\">Scorekeeper<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/bgg-api\">API Call and Cache<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/kitchensink\">Kitchen Sink<\/a><\/li>\n<\/ul>\n"
        }]
      },
      "feature-overview": {
        "ownKey": "feature-overview",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "feature-overview",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/feature-overview"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "mental-model",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/mental-model"
          },
          "description": "",
          "title": "Features",
          "content": "<h1 id=\"high-level-feature-overview\"><a href=\"#high-level-feature-overview\" id=\"high-level-feature-overview\" class=\"anchor\"><\/a>High-level Feature Overview<\/h1>\n<h2 id=\"viewmodels\"><a href=\"#viewmodels\" id=\"viewmodels\" class=\"anchor\"><\/a>ViewModels<\/h2>\n<p>The ViewModel is Ballast's container for implementing the MVI pattern. It holds onto all data and assembles your\ncomponents together to process work in a predictable manner. There are a number of ViewModel implementations provided by\nBallast to run in a variety of scenarios, such as:<\/p>\n<ul>\n<li><code>AndroidViewModel<\/code>: A subclass of <code>androidx.lifecycle.ViewModel<\/code><\/li>\n<li><code>IosViewModel<\/code>: A custom ViewModel that is tied to an iOS <code>ViewController<\/code>'s lifecycle<\/li>\n<li><code>BasicViewModel<\/code>: A generic ViewModel which can be used in any arbitrary context, including Kotlin targets that don't\nhave their own platform-specific ViewModel. <code>BasicViewModel<\/code>'s lifecycle is controlled by a <code>coroutineScope<\/code> provided\nto it upon creation.<\/li>\n<\/ul>\n<p>Typically, a single ViewModel serves as the store for a single Screen, and is not shared among multiple screens. Data\nthat should persist through multiple screens should either be passed directly through the navigation request, or be\nmanaged by your <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">repository layer<\/a> and re-fetched from the later screen.<\/p>\n<h2 id=\"contracts\"><a href=\"#contracts\" id=\"contracts\" class=\"anchor\"><\/a>Contracts<\/h2>\n<p>The Contract is a declarative model what is happening in a screen. The Contract is entirely separate from any Ballast\nAPIs, so while the snippet below shows the opinionated structure of a ViewModel's Contract, you are free to swap it out\nfor any other classes you may already have defined. There is no requirement for any of these components to serializable\nin any way.<\/p>\n<p>The contract is canonically a single top-level <code>object<\/code> with a name like <code>*Contract<\/code>, and it has 3 nested classes named\n<code>State<\/code>, <code>Inputs<\/code>, and <code>Events<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">object LoginScreenContract {\n    data class State(\n        val username: TextFieldValue,\n        val password: TextFieldValue,\n    )\n\n    sealed class Inputs {\n        data class UsernameChanged(val newValue: TextFieldValue) : Inputs()\n        data class PasswordChanged(val newValue: TextFieldValue) : Inputs()\n        object LoginButtonClicked : Inputs()\n        object RegisterButtonClicked : Inputs()\n    }\n\n    sealed class Events {\n        object NavigateToDashboard : Events()\n        object NavigateToRegistration : Events()\n    }\n}\n<\/code><\/pre>\n<h3 id=\"state\"><a href=\"#state\" id=\"state\" class=\"anchor\"><\/a>State<\/h3>\n<p>The most important component of the MVI contract, and of the Ballast library, is the State. All the data in your UI that\nchanges meaningfully should be modeled in your State. States are persistent, held in-memory, and guaranteed to always\nexist through the StateFlow. You will typically observe a <code>StateFlow<\/code> of your ViewModel state, but you can also access\nit once as a snapshot at that point in time. How you build your UI and model your Inputs should be derived completely\nfrom how you model your State.<\/p>\n<p>State is modeled as a Kotlin immutable <code>data class<\/code>:<\/p>\n<pre><code class=\"language-kotlin\">data class State(\n    val loggingIn: Boolean = false,\n    val username: TextFieldValue = TextFieldValue(),\n    val password: TextFieldValue = TextFieldValue(),\n)\n<\/code><\/pre>\n<p>Many articles on MVI suggest for using a <code>sealed class<\/code> to model UI state. However, experience has shown me that UI\nstates are rarely so cleanly delineated between such discrete states; you're more likely to have the UI go through a\nrange of mixed values and states as data is loaded, refreshed, or changed by the user. Additionally, a <code>sealed class<\/code> as\nyour State is only capable of modeling a single feature, but real-world UIs commonly have many features that all must be\nmodeled simultaneously.<\/p>\n<p>For these reasons, Ballast's opinion is that the Contract's State class should be a <code>data class<\/code>. But <code>sealed classes<\/code>\nwork great as individual properties within that State!<\/p>\n<h3 id=\"inputs\"><a href=\"#inputs\" id=\"inputs\" class=\"anchor\"><\/a>Inputs<\/h3>\n<p>Inputs are the core of how Ballast does all its processing. The &quot;intent&quot; a user has when interacting with the UI is\ncaptured into an Input class, which is sent to the Ballast ViewModel and scheduled to be processed at some later point\nin time.<\/p>\n<p>Inputs are modeled as a Kotlin <code>sealed class<\/code>:<\/p>\n<pre><code class=\"language-kotlin\">sealed class Inputs {\n    data class UsernameChanged(val newValue: TextFieldValue) : Inputs()\n    data class PasswordChanged(val newValue: TextFieldValue) : Inputs()\n    object LoginButtonClicked : Inputs()\n    object RegisterButtonClicked : Inputs()\n}\n<\/code><\/pre>\n<p>A good rule of thumb is to avoid re-using any Inputs for more than 1 purpose. It should be entirely clear what an Input\nwill do to the State <em>without having to look at its implementation or the State<\/em>. If you are tempted to re-send the same\ninput to do 2 different things, it should just be 2 different Inputs.<\/p>\n<h3 id=\"events\"><a href=\"#events\" id=\"events\" class=\"anchor\"><\/a>Events<\/h3>\n<p>A necessary feature of UI programming is to handle actions once, only once, and only at the appropriate time (such as\nNavigation requests). The processing of these Events is typically tightly coupled to the UI framework itself and doesn't\nmake much sense to be modeled in the State because the request is not persistent. Ballast uses Events as a way to keep\nthe platform-specific event-handling logic out of the ViewModel while ensuring all the guarantees of one-off Events that\none would expect.<\/p>\n<p>Like Inputs, Events are modeled as a Kotlin <code>sealed class<\/code>:<\/p>\n<pre><code class=\"language-kotlin\">sealed class Events {\n    object NavigateToDashboard : Events()\n    object NavigateToRegistration : Events()\n}\n<\/code><\/pre>\n<h2 id=\"handlers\"><a href=\"#handlers\" id=\"handlers\" class=\"anchor\"><\/a>Handlers<\/h2>\n<p>Everything in the Contract is entirely declarative, but at some point Ballast needs to <em>do something<\/em> with everything in\nthe Contract. There are several elements of a complete Ballast ViewModel that get composed together to implement the\nfull MVI pattern.<\/p>\n<h3 id=\"input-handlers\"><a href=\"#input-handlers\" id=\"input-handlers\" class=\"anchor\"><\/a>Input Handlers<\/h3>\n<p>All of Ballast's processing revolves, literally, around the Input Handler. It is the only place in the MVI loop that is\nallowed to run arbitrary code, and it is based upon Kotlin Coroutines to allow the entire processor loop to run\nasynchronously. Inputs that get sent to a ViewModel are placed into a queue, and the Input Handler pulls them out of the\nqueue one-at-a-time to be processed.<\/p>\n<p>And InputHandler is a class which implements the <code>InputHandler<\/code> interface. The <code>InputHandler.handleInput()<\/code> callback\nreceives a generic <code>Input<\/code> which should get split out into its sealed subclasses with a <code>when<\/code> statement. The\nInputHandler will be provided to the ViewModel upon its creation.<\/p>\n<pre><code class=\"language-kotlin\">import LoginScreenContract.*\n\nclass LoginScreenInputHandler : InputHandler&lt;Inputs, Events, State&gt; {\n    override suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(\n        input: Inputs\n    ) = when (input) {\n        is UsernameChanged -&gt; { }\n        is PasswordChanged -&gt; { }\n        is LoginButtonClicked -&gt; { }\n        is RegisterButtonClicked -&gt; { }\n    }\n}\n<\/code><\/pre>\n<p>The <code>InputHandlerScope<\/code> DSL is able to update the ViewModel State, post Events, start sideJobs, and call any other\nsuspending functions within the Input queue.<\/p>\n<h3 id=\"event-handlers\"><a href=\"#event-handlers\" id=\"event-handlers\" class=\"anchor\"><\/a>Event Handlers<\/h3>\n<p>The Event Handler works very similarly to the Input Handler, but should implement <code>EventHandler<\/code> instead. Events are\nsent from the Input Handler into a queue, and the EventHandler will pull them out of the queue to be processed\none-at-a-time.<\/p>\n<p>Inputs are sent from the UI into the ViewModel, and finally delivered to the Input Handler. The Event Handler is the\nexact opposite, handling Events sent from the ViewModel to the UI. But crucially, the ViewModel may live longer than the\nUI element it is associated with, and so the EventHandler may be attached and detached dynamically in response to the\nUI element's own lifecycle. Events sent while the Event Handler is detached will be queued, and will only be delivered\nto the EventHandler once the UI is back in a valid lifecycle state.<\/p>\n<pre><code class=\"language-kotlin\">import LoginScreenContract.*\n\nclass LoginScreenEventHandler : EventHandler&lt;Inputs, Events, State&gt; {\n    override suspend fun EventHandlerScope&lt;Inputs, Events, State&gt;.handleEvent(\n        event: Events\n    ) = when (event) {\n        is Events.Notification -&gt; { }\n    }\n}\n<\/code><\/pre>\n<p>The <code>EventHandlerScope<\/code> DSL is able to post Inputs back into the queue.<\/p>\n<h3 id=\"side-jobs\"><a href=\"#side-jobs\" id=\"side-jobs\" class=\"anchor\"><\/a>Side-jobs<\/h3>\n<p>Inputs are normally processed in a queue, one-at-a-time, but there are lots of great use-cases for concurrent work in\nthe MVI model. Side-jobs allow you to start coroutines that run in the &quot;background&quot; of your ViewModel, on the side of\nthe normal Input queue. These side-jobs are bound by the same lifecycle as the ViewModel, and can even collect from\ninfinite flows.<\/p>\n<p>Unlike all other components in Ballast, Side-jobs are just part of the <code>InputHandlerScope<\/code> DSL. You call\n<code>sideJob()<\/code>, provide it with a <code>key<\/code> that is used to determine when to restart it, and run your code in the lambda.<\/p>\n<pre><code class=\"language-kotlin\">override suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(\n    input: Inputs\n) = when (input) {\n    is InfiniteSideJob -&gt; {\n        sideJob(&quot;ShortSideJob&quot;) {\n            infiniteFlow()\n                .map { Inputs.SomeInputType() }\n                .onEach { postInput(it) }\n                .launchIn(this)\n        }\n    }\n}\n<\/code><\/pre>\n<p>The <code>sideJob()<\/code> lambda's receiver DSL is able to post both Inputs and Events back to the ViewModel. It also includes\na snapshot of the State taken when the SideJob is started, and a flag to let you know if the sideJob is started\nfor the first time or restarted.<\/p>\n<h2 id=\"configuration\"><a href=\"#configuration\" id=\"configuration\" class=\"anchor\"><\/a>Configuration<\/h2>\n<p>The above sections outline the overall <em>usage<\/em> of Ballast, but there are a few more useful features that can expand the\nfunctionality of Ballast with its configuration.<\/p>\n<h3 id=\"config-builder\"><a href=\"#config-builder\" id=\"config-builder\" class=\"anchor\"><\/a>Config Builder<\/h3>\n<p>All ViewModels will require a <code>BallastViewModelConfiguration<\/code> provided when they're created where most of the\nconfiguration takes place, but some platform-specific ViewModel classes may need some additional configuration, too. A\nBasicViewModel configuration looks like this, using the helpful <code>BallastViewModelConfiguration.Builder<\/code>:<\/p>\n<pre><code class=\"language-kotlin\">public class ExampleViewModel(\n    viewModelScope: CoroutineScope\n) : BasicViewModel&lt;Inputs, Events, State&gt;(\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            // set configuration common to all ViewModels, if needed\n        }\n        .forViewModel(\n            initialState = State(),\n            inputHandler = ExampleInputHandler(),\n            name = &quot;Example&quot;\n        ),\n    eventHandler = ExampleEventHandler(),\n    coroutineScope = viewModelScope,\n)\n<\/code><\/pre>\n<h3 id=\"interceptors\"><a href=\"#interceptors\" id=\"interceptors\" class=\"anchor\"><\/a>Interceptors<\/h3>\n<p>One of the primary features of Ballast, and indeed one of the biggest benefits of the MVI pattern in general, is it\nability to decouple the <em>intent<\/em> to do work from the actual processing of that work. Because of this separation, it\nmakes it possible to intercept all the objects moving throughout the ViewModel and add a bunch of other really useful\nfunctionality, without requiring any changes to the Contract or Processor code.<\/p>\n<p>A basic Interceptor works like a <a href=\"https://en.wikipedia.org/wiki/Decorator_pattern\">Decorator<\/a>, being attached to the ViewModel without affecting any of the normal\nprocessing behavior of the ViewModel. It receives <code>BallastNotifications<\/code> from the ViewModel to notify the status of\nevery feature as it goes through the steps of processing, such as being queued, completed, or failed. Basic Interceptors\nare purely a read-only mechanism, and are not able to make any changes to the ViewModel.<\/p>\n<pre><code class=\"language-kotlin\">public class CustomInterceptor&lt;Inputs : Any, Events : Any, State : Any&gt;(\n) : BallastInterceptor&lt;Inputs, Events, State&gt; {\n\n    override suspend fun onNotify(logger: BallastLogger, notification: BallastNotification&lt;Inputs, Events, State&gt;) {\n        // do something\n    }\n}\n<\/code><\/pre>\n<p>More advanced Interceptors are given additional privileges and are able to push changes back to the ViewModel. Rather\nthan being notified when something interesting happens, they are notified when the ViewModel starts up and are given\ndirect access to the Notifications flow, as well as a way to send data directly back into the ViewModel's processing\nqueue, for doing unique and privileged things like time-travel debugging. Advanced Interceptors are able to restore the\nViewModel state arbitrarily, and send Inputs back to the ViewModel for processing, both of which will be handled\nprocessed in the normal queue by the InputStrategy.<\/p>\n<pre><code class=\"language-kotlin\">public class CustomInterceptor&lt;Inputs : Any, Events : Any, State : Any&gt;(\n) : BallastInterceptor&lt;Inputs, Events, State&gt; {\n\n    public fun BallastInterceptorScope&lt;Inputs, Events, State&gt;.start(\n        notifications: Flow&lt;BallastNotification&lt;Inputs, Events, State&gt;&gt;,\n    ) {\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            notifications.collect {\n                onNotify(logger, it)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<p>Ballast offers a number of useful Interceptors and modules to aid in debugging and monitoring your application, see\n<a href=\"https://copper-leaf.github.io/ballast/wiki/modules\">Modules<\/a>.<\/p>\n<h3 id=\"input-strategy\"><a href=\"#input-strategy\" id=\"input-strategy\" class=\"anchor\"><\/a>Input Strategy<\/h3>\n<p>Until now in this page, I've described the Ballast ViewModel's internals as a &quot;queue&quot; and they're processed\n&quot;one-at-a-time&quot;, but that's not entirely accurate. More specifically, Inputs are buffered into a Kotlin Coroutine\nChannel, and Ballast offers an API for customizing exactly how the Inputs are read from that channel.<\/p>\n<p>Ballast offers 3 different Input Strategies out-of-the-box, which each adapt Ballast's core functionality for different\napplications:<\/p>\n<ul>\n<li><code>LifoInputStrategy<\/code>: A last-in-first-out strategy for handling Inputs, and the default strategy if none is provided.\nOnly 1 Input will be processed at a time, and if a new Input is received while one is still working, the running Input\nwill be cancelled to immediately accept the new one. Corresponds to <code>Flow.collectLatest { }<\/code>, best for UI ViewModels.<\/li>\n<li><code>FifoInputStrategy<\/code>: A first-in-first-out strategy for handling Inputs. Inputs will be processed in the same order\nthey were sent and only ever one-at-a-time, but instead of cancelling running Inputs, new ones are queued and will be\nconsumed later when the queue is free. Corresponds to the normal <code>Flow.collect { }<\/code>, best for non-UI ViewModels.<\/li>\n<li><code>ParallelInputStrategy<\/code>: For specific edge-cases where neither of the above strategies works. Inputs are all handled\nconcurrently so you don't have to worry about blocking the queue or having Inputs cancelled. However, it places\nadditional restrictions on State reads/changes to prevent usage that might lead to race conditions.<\/li>\n<\/ul>\n<p>InputStrategies are responsible for creating the Channel used to buffer incoming Inputs, consuming the Inputs from that\nchannel, and providing a &quot;Guardian&quot; to ensure the Inputs are handled properly according the needs of that particular\nstrategy. The <code>DefaultGuardian<\/code> is a good starting place if you need to create your own <code>InputStrategy<\/code> to\nmaintain the same level of safety as the core strategies listed above.<\/p>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>Pro Tip: The text descriptions of these InputStrategies can be a bit confusing, but seeing them play out in real-time\nshould make it obvious how they work. Playing with the <a href=\"https://copper-leaf.github.io/ballast/wiki/examples/kitchensink\">Kitchen Sink<\/a> with the <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Debugger<\/a> gives you a simple way\nof experiencing these behaviors to get an intuition for when to use each one.<\/p>\n  <\/div>\n<\/article>\n<h3 id=\"logging\"><a href=\"#logging\" id=\"logging\" class=\"anchor\"><\/a>Logging<\/h3>\n<p>Ballast offers a simple logging API integrated throughout the library. An instance of <code>BallastLogger<\/code> installed in the\n<code>BallastViewModelConfiguration<\/code> is exposed through all interfaces where custom code is run, so you don't have to juggle\ninjecting Loggers and properly matching up tags amongst all the different classes that make up the Ballast ViewModel.<\/p>\n<pre><code class=\"language-kotlin\">import LoginScreenContract.*\n\nclass LoginScreenInputHandler : InputHandler&lt;Inputs, Events, State&gt; {\n    override suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(\n        input: Inputs\n    ) = when (input) {\n        is UsernameChanged -&gt; { }\n        is PasswordChanged -&gt; { }\n        is LoginButtonClicked -&gt; { \n            logger.info(&quot;Attempting Logging In...&quot;)\n            val loginSuccessful = attemptLogin()\n            if(loginSuccessful) {\n                logger.info(&quot;Login success&quot;)\n            } else {\n                logger.info(&quot;Login failed&quot;)\n            }\n        }\n        is RegisterButtonClicked -&gt; { }\n    }\n}\n<\/code><\/pre>\n<p>Ballast offers several logger implementations out-of-the-box:<\/p>\n<ul>\n<li><code>NoOpLogger<\/code>: The default implementation, it simply drops all messages and exceptions so nothing gets logged\naccidentally. It's recommended to use this in production builds, as well, and using <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase\">Ballast Firebase<\/a> to control\nwhat actually gets logged in production.<\/li>\n<li><code>PrintlnLogger<\/code>: Useful for quick-and-dirty logging on all platforms. It just writes log messages to stdout through\nprintln.<\/li>\n<li><code>AndroidBallastLogger<\/code>: Only available on Android, writes logs to the default LogCat at the appropriate levels.<\/li>\n<\/ul>\n<p>By default, only logs written directly to the logger will be displayed, but by installing the <code>LoggingInterceptor<\/code> into\nthe <code>BallastViewModelConfiguration<\/code> you'll get automatic logging of all activity within the ViewModel. This interceptor\nmaintains a list of all Inputs and a copy of the latest State, so it may consume large amounts of memory or write\nsensitive information to the logger, and as such should never be used in production.<\/p>\n"
        }]
      },
      "changelog": {
        "ownKey": "changelog",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "changelog",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/changelog"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "roadmap",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/roadmap"
          },
          "description": "",
          "title": "Changelog",
          "content": ""
        }]
      },
      "mental-model": {
        "ownKey": "mental-model",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "mental-model",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/mental-model"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "usage-guide",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/usage-guide"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "feature-overview",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/feature-overview"
          },
          "description": "",
          "title": "Thinking in Ballast MVI",
          "content": "<h1 id=\"thinking-in-ballast-mvi\"><a href=\"#thinking-in-ballast-mvi\" id=\"thinking-in-ballast-mvi\" class=\"anchor\"><\/a>Thinking in Ballast MVI<\/h1>\n<h2 id=\"ballast-overview\"><a href=\"#ballast-overview\" id=\"ballast-overview\" class=\"anchor\"><\/a>Ballast Overview<\/h2>\n<p>Ballast is a library implementing an opinionated structure of the MVI state management architecture pattern, based on\nthe concept Unidirectional Data Flow. This pattern has been used and implemented by a variety of libraries across many\nlanguages and under a variety of names, such as <a href=\"https://facebook.github.io/flux/\">Flux<\/a>, <a href=\"https://redux.js.org/\">Redux<\/a>, <a href=\"https://vuex.vuejs.org/\">Vuex<\/a>, <a href=\"https://guide.elm-lang.org/architecture/\">The Elm Architecture<\/a>, <a href=\"https://www.raywenderlich.com/817602-mvi-architecture-for-android-tutorial-getting-started\">MVI<\/a>,\n<a href=\"https://developer.android.com/jetpack/compose/architecture\">UDF<\/a>, etc. The idea behind all these libraries is sound and leads to clean UI architecture, and Ballast is just one\nparticular way to do it. The above links are also good sources for understanding this pattern more generally, as well.<\/p>\n<p>The core idea is to model your UI not as discrete UI elements with click listeners, changing text, local state, etc.\nthat all needs to be synced and updated manually, but instead to lift that state into a ViewModel and update the entire\nUI whenever the ViewModel state changes. This idea of &quot;lifting state&quot; naturally forms a loop in your UI, where:<\/p>\n<ul>\n<li>the <strong>ViewModel<\/strong> holds <strong>State<\/strong>, which gets pushed to the UI with every change<\/li>\n<li>the UI updates itself to match the current <strong>State<\/strong><\/li>\n<li>The user interacts with the UI, producing <strong>Inputs<\/strong>, or their &quot;intent&quot; to change the UI state.<\/li>\n<li>The <strong>Inputs<\/strong> get sent back to the <strong>ViewModel<\/strong>, where it processes the <strong>Inputs<\/strong> to change the State<\/li>\n<\/ul>\n<p>Notably, in this loop, the UI is never responsible for updating the <strong>State<\/strong> itself, and there is no business logic\ncode that depends on any data held anywhere but the <strong>State<\/strong>. The UI only dispatches <strong>Inputs<\/strong> directing the ViewModel\nto update the state, and all processing is done within the <strong>ViewModel<\/strong>, asynchronously, and any changes to the\n<strong>State<\/strong> as a result of processing an <strong>Input<\/strong> will be pushed back to the UI automatically. You can visualize the loop\nlike so:<\/p>\n<pre><code class=\"language-mermaid\">graph\n    ViewModel--State--&gt;UI\n    UI--Inputs--&gt;ViewModel\n<\/code><\/pre>\n<p>This diagram is the simplest form of MVI, but Ballast adds a bit more structure and more features to this core loop,\nwhich are needed to build a fully-functional and <em>safe<\/em> UI &quot;state machine&quot;. Ballast itself is built around Kotlin\n<a href=\"https://kotlinlang.org/docs/coroutines-overview.html\">Coroutines<\/a>,\n<a href=\"https://elizarov.medium.com/structured-concurrency-722d765aa952\">Structured Concurrency<\/a>,\nand <a href=\"https://kotlinlang.org/docs/flow.html\">Flows<\/a>, though familiarity with them is not strictly necessary to use\nBallast. A more complete diagram of the Ballast MVI model looks more like the diagram below. See\n<a href=\"https://copper-leaf.github.io/ballast/wiki/feature-overview\">Features<\/a> for more information on the features described in this diagram.<\/p>\n<pre><code class=\"language-mermaid\">flowchart TD\n    subgraph UI\n        View\n        EventHandler\n    end\n    subgraph ViewModel\n        InputChannel\n        EventChannel\n        InputFilter\n        InputHandler\n        SideJob\n\n        InputChannel--Inputs--&gt;InputFilter\n        InputFilter--Reject--&gt;id1{Rejected}\n        InputFilter--Accept--&gt;InputHandler\n\n        InputHandler--postEvent--&gt;EventChannel\n        InputHandler--updateState--&gt;StateFlow\n        InputHandler--sideJob--&gt;SideJob\n        EventChannel--Events--&gt;EventHandler\n        EventHandler--postInput--&gt;InputChannel\n\n        SideJob--postInput--&gt;InputChannel\n        SideJob--postEvent--&gt;EventChannel\n    end\n\n    View--trySend--&gt;InputChannel\n    StateFlow--ObserveState--&gt;View\n<\/code><\/pre>\n<h2 id=\"ui-programming-through-the-years\"><a href=\"#ui-programming-through-the-years\" id=\"ui-programming-through-the-years\" class=\"anchor\"><\/a>UI Programming Through the Years<\/h2>\n<p>To better understand the MVI pattern, how Ballast implements it, and why certain things are done in this way, let's go\nback in time and walk through the evolution of UI programming through the years to understand how MVI came to be the\nfavored pattern that it is today.<\/p>\n<p>Note that this brief history is based on my personal experiences and observations over the last ~10 years of software\ndevelopment, and draws heavily from a native Android and web dev perspective. You may have a different opinion on the\nexact timelines, descriptions, pros, or cons of certain patterns, but I'm not looking to start an argument. I'm simply\nwanting to show the evolution that I have observed, that ultimately led to the Ballast MVI library as it stands today.<\/p>\n<h3 id=\"traditional-ui-programming\"><a href=\"#traditional-ui-programming\" id=\"traditional-ui-programming\" class=\"anchor\"><\/a>Traditional UI programming<\/h3>\n<p>In traditional UI programming, there is no separation (or only superficial separation) between the UI elements and the\ncode that is run when interacting with those elements. Take the following snippet, which is something you might see in a\ntraditional Android Activity's UI implementing a simple counter:<\/p>\n<pre><code class=\"language-kotlin\">override fun onCreate() {\n    setContentView(R.layout.activity_main)\n    val button: Buttoon = findViewById(R.id.button)\n    val counterText: TextView = findViewById(R.id.counter_text)\n\n    button.setOnClickListener {\n        val currentCount = counterText.text.toString().toInt()\n        val incrementedCount = currentCount + 1\n        counterText.setText(&quot;$incrementedCount&quot;)\n    }\n}\n<\/code><\/pre>\n<p>For comparison, here's the same thing in HTML/JS.<\/p>\n<pre><code class=\"language-js\">var button = document.getElementById(&quot;button&quot;);\nvar counterText = document.getElementById(&quot;counter_text&quot;);\n\nfunction handleClick() {\n    var currentCount = parseInt(counterText.textContent)\n    var incrementedCount = currentCount + 1\n    counterText.innerHTML = incrementedCount\n}\nbutton.onclick = handleClick\n<\/code><\/pre>\n<p>This approach, so common in many older applications, has a number of problems:<\/p>\n<ul>\n<li>How do we get the current counter value?\n<ul>\n<li>Answer: get the text directly from the UI element, and parse it to a String<\/li>\n<\/ul>\n<\/li>\n<li>What happens if the text in the UI element is not a valid number?\n<ul>\n<li>Answer: <code>¯\\_(ツ)_/¯<\/code><\/li>\n<\/ul>\n<\/li>\n<li>What happens if the button is clicked many times very quickly?\n<ul>\n<li>Answer: Clicks must be handled on the main UI thread, to make sure there are no race conditions<\/li>\n<\/ul>\n<\/li>\n<li>Ok, but what if it does get called quickly from many different threads?\n<ul>\n<li>Answer: <code>¯\\_(ツ)_/¯<\/code><\/li>\n<\/ul>\n<\/li>\n<li>How do I test this code?\n<ul>\n<li>Answer: You'll need to run your tests in a real device/browser or emulated environment<\/li>\n<\/ul>\n<\/li>\n<li>What if that button click needs to make an API call?\n<ul>\n<li>Answer: You'll need to run that code in the background, receive the callback on the main thread, and update the UI in that\ncallback<\/li>\n<\/ul>\n<\/li>\n<li>What if the data stored in the UI changes by the time the API call returns?\n<ul>\n<li>Answer: <code>¯\\_(ツ)_/¯<\/code><\/li>\n<\/ul>\n<\/li>\n<li>I saw a really strange bug report. How can I reproduce that bug?\n<ul>\n<li>Answer: Manually follow the exact series of steps that put the user in that scenario<\/li>\n<\/ul>\n<\/li>\n<li>How do I figure out those steps that the user did?\n<ul>\n<li>Answer: <code>¯\\_(ツ)_/¯<\/code><\/li>\n<\/ul>\n<\/li>\n<li>What if the UI state is a result of parallelism and was a freak occurrence?\n<ul>\n<li>Answer: <code>¯\\_(ツ)_/¯<\/code><\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<h3 id=\"mvp\"><a href=\"#mvp\" id=\"mvp\" class=\"anchor\"><\/a>MVP<\/h3>\n<ul>\n<li><em>Not really used on Web<\/em><\/li>\n<li><em>2013 to 2019 on Android<\/em><\/li>\n<\/ul>\n<p>Early attempts to solve these problems started to spring up, especially with the <strong>MVP<\/strong> pattern on Android. The main\nidea here was to move all the &quot;business logic&quot; code out of the &quot;view&quot; and into a &quot;presenter&quot; class. The View connects\nall its clicks and other interactions to call methods on the Presenter, and the Presenter acts as fake &quot;view&quot; so the\ncode isn't directly tied to the Android View or Browser.<\/p>\n<pre><code class=\"language-kotlin\">class CounterPresenter(private val view: CounterView) {\n    private var currentCount = 0\n    fun onButtonClick() {\n        val incrementedCount = currentCount + 1\n        view.setCounterText(&quot;$incrementedCount&quot;)\n        currentCount = incrementedCount\n    }\n}\n\ninterface CounterView {\n    fun setCounterText(text: String)\n}\n\nclass CounterActivity : AppCompatActivity(), CounterView {\n\n    override fun onCreate() {\n        setContentView(R.layout.activity_main)\n        val button: Buttoon = findViewById(R.id.button)\n        val presenter = CounterPresenter(this)\n\n        button.setOnClickListener {\n            presenter.onButtonClick()\n        }\n    }\n\n    override fun setCounterText(text: String) {\n        val counterText: TextView = findViewById(R.id.counter_text)\n        counterText.setText(&quot;$incrementedCount&quot;)\n    }\n}\n<\/code><\/pre>\n<p>This approach gained a lot of popularity because it allowed one to test the busisness logic in a normal unit test,\nwithout needing a full real or emulated environment. But this approach has a number of flaws, some of which are inherent\nin its design, and some are just problems with the real-world implementation of it.<\/p>\n<ul>\n<li>The Presenter had to add a <code>currentCount<\/code> variable, since it no longer has direct access to the View to read the\ncurrent text in the UI element. We now have the same value in 2 separate places.<\/li>\n<li>What if we want to change the <code>currentCount<\/code> variable from multiple places?\n<ul>\n<li>Answer: We need to make sure that code updates both the internal variable and the UI element<\/li>\n<\/ul>\n<\/li>\n<li>What's the value shown in the UI before clicking the button?\n<ul>\n<li>Answer: We need to make sure the default value in the UI matches that of the Presenter's value.<\/li>\n<\/ul>\n<\/li>\n<li>What if I need to make a really quick addition to the UI. Do I really have to jump through all these hoops?\n<ul>\n<li>Answer: Yes. The MVP pattern means you need to add all the boilerplate for it.<\/li>\n<\/ul>\n<\/li>\n<li>But this really needs to go out quickly. I'm just going to do it the normal way.\n<ul>\n<li>Answer: I mean, I can't really stop you, but you really shouldn't...<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<p>And this is the main reason why I personally don't think MVP is a very good design pattern. It is really only a\nsuperficial separation, but you're basically writing the same code you would normally but with much more boilerplate.\nThere is nothing in the pattern itself that requires you to follow it, and in practice, it's likely you'll run into\nportions of code that do not follow the pattern strictly, giving you a frankenstein mix of code split between\nprogramming styles, and state being held all over the place, leaving you worse off than not having the MVP pattern at\nall.<\/p>\n<p>MVP: Good in theory, but rarely implemented well in practice.<\/p>\n<h3 id=\"mvvm\"><a href=\"#mvvm\" id=\"mvvm\" class=\"anchor\"><\/a>MVVM<\/h3>\n<ul>\n<li><em>2010 to 2016 on web with Angular.JS<\/em><\/li>\n<li><em>2016 to 2019 on Android with Databinding, but never became too popular<\/em><\/li>\n<\/ul>\n<p>Once everyone started noticing the problems inherent in traditional- and MVP-style UI programming, the natural fix\nbecame pretty apparent: rather than the interactions driving the UI, let's use a state model to drive the UI. One starts\nby developing creating a model of the screen's state, and then builds a UI that is assembled or synchronized to match\nthat model.<\/p>\n<p>These are the early days of reactive programming, when Angular.JS because king, React was just starting to be developed,\nand all the UI toolkits started creating their own &quot;MVVM&quot; frameworks. The main idea with these is that you take\nsomething like a &quot;Presenter&quot; or &quot;Controller&quot; class, declare the state that lives within that Controller, and let a\nframework worry about applying that state to the UI for you. Additionally, the MVVM frameworks bind in the other\ndirection, too, automatically wiring up click listeners and such so that they always run code in the Controller.<\/p>\n<p>This was a huge improvement over the previous attempts. We now have a way to make sure any changes to the state will\nalways be present in the UI, even changes made from other threads, and the framework enforces that all changes to the\nUI must go through the Controller and the MVVM framework.<\/p>\n<p>MVVM started with Angular.JS and we started seeing MVVM frameworks popping up everywhere: Android, Xamarin, a thousand\ndifferent Javascript frameworks, etc. But MVVM is not without its issues: most notably being that the MVVM framework\nneeds to have intimate knowledge of both the View and your Controller. The framework itself would have to be updated\nanytime the underlying Views changed, as well as knowing about all container types that might hold data in the\nController, to know how to convert those values into something displayed in the UI.<\/p>\n<p>As a result, MVVM frameworks tended to lag behind the actual frameworks themselves, the frameworks themselves were\npretty large and might not always have the best performance, and especially for things like displaying lists of content,\nit was just more difficult than it needed to be.<\/p>\n<h3 id=\"mvi\"><a href=\"#mvi\" id=\"mvi\" class=\"anchor\"><\/a>MVI<\/h3>\n<ul>\n<li><em>2013 to now on web, with React<\/em><\/li>\n<li><em>2019 to now on Android, with Compose<\/em><\/li>\n<li><em>2019 to now on iOS, with Swift UI<\/em><\/li>\n<li><em>2017 to now with Flutter<\/em><\/li>\n<\/ul>\n<p>MVI was the next iteration of UI programming, and by all accounts it seems to be the one that will stick around. It\nsolves many of the problems outlined with traditional programming, but does it in a much more lightweight and\nunobtrusive way than MVVM, giving all the power back into the hands of the programmer and allowing them to write the\nsame code they would expect when working with a UI toolkit, but providing structure around the state and interactions\nrequired of the UI.<\/p>\n<p>The core difference between MVVM and MVI is this: MVVM uses an automated middle-man to apply state to UI and send\nchange requests from the UI to the Controller (or ViewModel). MVI forgoes that middleman and implements a more\ntransparent mechanism for moving State and Inputs between the UI and ViewModel, and asks the programmer to be that\nmiddle-man. Instead of automatically applying the State to the UI, the MVI pattern gives the programmer the State that\nshould be applied to the UI, and allows the programmer to pick their UI toolkit and programming style to apply the\nState themselves.<\/p>\n<p>This idea is what Facebook started with the Flux architecture and React, and soon afterwards you started seeing more and\nmore platforms rewriting their UI toolkits around this exact philosophy. Flutter, Swift UI, Jetpack Compose, all based\naround this idea that the UI shouldn't have to manage anything itself, but should be driven entirely by some model of\nState and applied to the UI with hand-written code.<\/p>\n<p>This MVI model has proven itself over the last few years to be incredibly durable and robust, even useful outside of\npure UI applications. And the more I work on Ballast and really figure out how this pattern works, the more flexible and\npowerful I find it to be, enabling all sorts of incredible use-cases that are simply impossible with traditional\nprogramming techniques, like time-travel debugging, undo/redo, multi-user synchronization, and many others.<\/p>\n<p>Hopefully this brief history of UI programming has given you some things to think about which will help you understand\nmore about the specific design choices of Ballast, as outlined throughout the rest of this document.<\/p>\n<h2 id=\"ui-contract\"><a href=\"#ui-contract\" id=\"ui-contract\" class=\"anchor\"><\/a>UI Contract<\/h2>\n<p>All of Ballast was designed around an opinionated way to write your UI code to optimize the MVI pattern and make all\nyour application screens/components look and work very similarly. It all starts with creating a &quot;Contract&quot;, and from\nthere we'll work to allow Ballast to manage that Contract.<\/p>\n<h3 id=\"modeling-a-ui-contract\"><a href=\"#modeling-a-ui-contract\" id=\"modeling-a-ui-contract\" class=\"anchor\"><\/a>Modeling a UI Contract<\/h3>\n<p>The convention with Ballast is to use one Ballast ViewModel for each screen in your application, and to create a\n&quot;contract&quot; for interfacing your UI to the screen's ViewModel. Note that Ballast works well with Compose or other\ndeclarative UI frameworks, but the model will still hold true even with standard Android Views as long as you make sure\nto manually update the UI widgets' state to match the ViewModel state. Anyway, start by defining the &quot;contract&quot;, for\nexample, a login screen.<\/p>\n<pre><code class=\"language-kotlin\">object LoginScreenContract {\n    data class State(\n        ...\n    )\n\n    sealed class Inputs {\n        ...\n    }\n\n    sealed class Events {\n        ...\n    }\n}\n<\/code><\/pre>\n<p>Each Contract is a top-level <code>object<\/code> with a nested <code>State<\/code> <code>data class<\/code>, and <code>sealed class<\/code>es for <code>Inputs<\/code> and <code>Events<\/code>.<\/p>\n<p><code>State<\/code> is the persistent state of the ViewModel, which will get pushed to the UI anytime it changes. The UI should\nupdate itself to display what's in that <code>State<\/code>, and in doing so will always be kept consistent with that State.<\/p>\n<p><code>Inputs<\/code> are how the UI communicates back to the ViewModel. Each discrete action in the UI, each click listener, text\nchanged listener, etc. should be separate classes within the <code>Input<\/code> sealed class. Each <code>Inputs<\/code> subclass is should be\nan <code>object<\/code> if the UI element doesn't directly deliver data to the ViewModel (a click listener), or a <code>data class<\/code> if\nit does need to deliver data (text changed). Don't worry about what to do with those yet, the Contract just defines the\n&quot;what&quot;.<\/p>\n<p><code>Events<\/code> are modeled similar to Inputs, but in the other direction; Events are sent from the ViewModel to be processed\nexactly once by the UI. This would typically be things like requests to navigate to another screen.<\/p>\n<p>Filling out the above contract for a Login Screen might end up looking like this:<\/p>\n<pre><code class=\"language-kotlin\">object LoginScreenContract {\n    data class State(\n        val username: TextFieldValue,\n        val password: TextFieldValue,\n    )\n\n    sealed class Inputs {\n        data class UsernameChanged(val newValue: TextFieldValue) : Inputs()\n        data class PasswordChanged(val newValue: TextFieldValue) : Inputs()\n        object LoginButtonClicked : Inputs()\n        object RegisterButtonClicked : Inputs()\n    }\n\n    sealed class Events {\n        object NavigateToDashboard : Events()\n        object NavigateToRegistration : Events()\n    }\n}\n<\/code><\/pre>\n<h3 id=\"what-not-to-put-in-a-ui-contract\"><a href=\"#what-not-to-put-in-a-ui-contract\" id=\"what-not-to-put-in-a-ui-contract\" class=\"anchor\"><\/a>What Not to put in a UI Contract<\/h3>\n<p>Obviously, the initial thought when building out a Contract is to put every single variable into the State, and you\nabsolutely can do that. But with sufficiently large screens, this may become a bit too verbose and introduce a lot of\nback-and-forth jumping between the UI and the VM, which may not be strictly necessary. Assuming your entire UI,\nincluding its listeners, is updated with each state change (both local and ViewModel states), you can leave some amount\nof logic purely in the UI, and have the State and Inputs only model the things which are actually important from a\nbusiness logic perspective.<\/p>\n<p>As an example, let's take a Checkout screen. At the end of the flow, once the user has entered all their information, we\nwant to show a popup to confirm the user actually wants to submit the order to help prevent accidental clicks submitting\nit for them. If we had the logic for this popup in the Contract, it would look something like this in Jetpack Compose:<\/p>\n<pre><code class=\"language-kotlin\">object CheckoutContract {\n    data class State(\n        val cart: List&lt;CartItem&gt;,\n        val isConfirmationDialogShowing: Boolean, // whether the popup should be open\n    )\n\n    sealed class Inputs {\n        ...\n\n        object CheckoutButtonClicked : Inputs() // open the popup\n        object ConfirmationDialogCheckoutButtonClicked : Inputs() // submit the order\n        object ConfirmationDialogCancelButtonClicked : Inputs() // close the popup\n        object ConfirmationDialogDismissed : Inputs() // close the popup\n    }\n\n    sealed class Events {\n        ...\n    }\n}\n\n@Composable\nfun Checkout(state: CheckoutContract.State, postInput: (CheckoutContract.Inputs)-&gt;Unit) {\n    ItemsInCard(state.cart)\n\n    Button(onClick = { postInput(CheckoutContract.Inputs.CheckoutButtonClicked) }) {\n        Text(&quot;Checkout&quot;)\n    }\n\n    if(state.isConfirmationDialogShowing) {\n        AlertDialog(\n            onDismissRequest = {\n                postInput(CheckoutContract.Inputs.ConfirmationDialogDismissed)\n            },\n            text = {\n                Text(&quot;Submit order?&quot;)\n            },\n            confirmButton = {\n                Button(onClick = { postInput(CheckoutContract.Inputs.ConfirmationDialogCheckoutButtonClicked) }) {\n                    Text(&quot;Submit&quot;)\n                }\n            },\n            dismissButton = {\n                Button(onClick = { postInput(CheckoutContract.Inputs.ConfirmationDialogCancelButtonClicked) }) {\n                    Text(&quot;Cancel&quot;)\n                }\n            }\n        )\n    }\n}\n<\/code><\/pre>\n<p>Now, there's nothing wrong with this, it's just a bit verbose. And looking at this snippet, it's not immediately obvious\nthat the purpose of all this code is just to show a confirmation dialog before submitting the order. It muddies up the\nactual intent and logic of this screen with a bunch of boilerplate, and since all of these events basically just toggles\na Boolean property, it's not really necessary to have all the structure and protections of Ballast managing it. A better\nway to handle it is to leave the popup logic entirely in the UI and understand that popup to just be a UI detail, but\nnot something business-critical that needs to be modeled in the Contract:<\/p>\n<pre><code class=\"language-kotlin\">object CheckoutContract {\n    data class State(\n        val cart: List&lt;CartItem&gt;,\n    )\n\n    sealed class Inputs {\n        ...\n\n        object CheckoutButtonClicked : Inputs() // submit the order\n    }\n\n    sealed class Events {\n        ...\n    }\n}\n\n@Composable\nfun Checkout(state: CheckoutContract.State, postInput: (CheckoutContract.Inputs)-&gt;Unit) {\n    ItemsInCard(state.cart)\n\n    var isConfirmationDialogShowing by remember { mutableStateOf(false) }\n\n    Button(onClick = { isConfirmationDialogShowing = true }) {\n        Text(&quot;Checkout&quot;)\n    }\n\n    if(isConfirmationDialogShowing) {\n        AlertDialog(\n            onDismissRequest = {\n                isConfirmationDialogShowing = false\n            },\n            text = {\n                Text(&quot;Submit order?&quot;)\n            },\n            confirmButton = {\n                Button(onClick = { postInput(CheckoutContract.Inputs.CheckoutButtonClicked) }) {\n                    Text(&quot;Submit&quot;)\n                }\n            },\n            dismissButton = {\n                Button(onClick = { isConfirmationDialogShowing = false }) {\n                    Text(&quot;Cancel&quot;)\n                }\n            }\n        )\n    }\n}\n<\/code><\/pre>\n<p>Notice how in this second snippet, it becomes more clear to see that clicking the main &quot;Checkout&quot; button does nothing\ndangerous, it only ever toggles a Boolean property. We can look at this code and know 100% for sure that the main\n&quot;Checkout&quot; button will never make the API call to submit the order. And it becomes easier to see exactly what point in\nthe UI <em>does<\/em> do something that could potentially trigger the API: hitting &quot;submit&quot; in the popup, since it's the only\nthing that posts an Input to the VM. We can also see from the Contract that submitting the order is the only truly\nimportant or potentially dangerous thing on this screen; anything else that <em>could<\/em> happen is just UI stuff, but none of\nthose actions to show the dialog or do anything else have the ability to submit any API calls because they never go\nthrough the Ballast ViewModel.<\/p>\n<p>Now, obviously, this is just an example. There may be perfectly legitimate use-cases for managing the state of a dialog\nin the Contract, such as displaying the result of an API call in a popup. There are also other use-cases for managing\nvariables in the UI and keeping them out of the Contract, such as disabling a submit button if a checkbox is not\nchecked. The main point is that Ballast is a tool to <em>help<\/em> you manage complex UIs as a state machine, but it does not\nneed to house every single property. There is nuance to how you structure a Contract. It's supposed to make it easier\nto read the code and understand what the UI is doing, and if it's getting bloated with a bunch of boilerplate inputs or\nstate properties, you may want to take a step back and ask yourself whether something actually needs to be in the\nViewModel or not.<\/p>\n<h3 id=\"kinds-of-state-classes\"><a href=\"#kinds-of-state-classes\" id=\"kinds-of-state-classes\" class=\"anchor\"><\/a>Kinds of State Classes<\/h3>\n<p>If you look online for how to model a UI state, you'll come across some common patterns, but also some anti-patterns. I\nfirmly believe that a <code>data class<\/code> is the best way to start modeling your UI state, and this is the form that is\nencouraged throughout the Ballast library and documentation. This section aims to show you why I believe this to be\nthe best starting point. That's not to say it's the best for all situations, but I do believe it will give you the best\nresult while causing the fewest difficulties in the majority of use-cases.<\/p>\n<h4 id=\"sealed-class\"><a href=\"#sealed-class\" id=\"sealed-class\" class=\"anchor\"><\/a>Sealed Class<\/h4>\n<p>Using a <code>sealed class<\/code> seems to be the most popular solution if you go by the articles you find on a quick web search.\nAnd it's clear to understand why: compared to the traditional way of building UIs, a sealed class gives you a way to\nensure that the data on your screen is consistent with itself. Take the following example from the article\n<a href=\"https://proandroiddev.com/modelling-ui-state-on-android-26314a5975b9\">Modelling UI State on Android<\/a>:<\/p>\n<pre><code class=\"language-kotlin\">sealed class TrafficLightState {\n    object Loading : TrafficLightState()\n    object Error : TrafficLightState()\n    data class Success(val color: Color) : TrafficLightState()\n}\n<\/code><\/pre>\n<p>This assumes that you visit a screen, it immediately starts loading data from a remote source, and then returns a\nresult. The result may have been the data you're looking for, or maybe something went wrong like a network failure, and\nthis form gives a clear indication of what exactly to show in the UI. You can also easily translate this into a UML\nstate diagram:<\/p>\n<pre><code class=\"language-mermaid\">stateDiagram-v2\n    [*] --&gt; Loading\n    Loading --&gt; Error\n    Loading --&gt; Success\n<\/code><\/pre>\n<p>But what happens if the error was an intermittent network failure, and you want to refresh the data? Then, it will move\nfrom <code>Error<\/code> back to <code>Loading<\/code>, and whatever error message you displayed is now hidden as the progress indicator is\nshown again. That's not an issue, this is probably what the user would expect. Here's the change needed to model this\naction in the state diagram:<\/p>\n<pre><code class=\"language-mermaid\">stateDiagram-v2\n    [*] --&gt; Loading\n    Loading --&gt; Error\n    Loading --&gt; Success\n    Error --&gt; Loading\n<\/code><\/pre>\n<p>But what if you added a pull-to-refresh action, so that the user can request the state update? The screen displayed the\ndata with the <code>Success<\/code> state, but then hides it all to display the progress indicator in the <code>Loading<\/code> state. Not great\nUX. Well, we can fix that by adding a new state to the UI, such as\n<code>data class Refreshing(val color: Color) : TrafficLightState()<\/code>, that can signal to the UI to display the progress\nindicator and the traffic light color at the same time. The state diagram now looks like this:<\/p>\n<pre><code class=\"language-mermaid\">stateDiagram-v2\n    [*] --&gt; Loading\n    Loading --&gt; Error\n    Loading --&gt; Success\n    Success --&gt; Refreshing\n    Refreshing --&gt; Error\n    Refreshing --&gt; Success\n<\/code><\/pre>\n<p>Or if we wanted to update the error refreshing state so that the error is still shown with the progress indicator over\nit, well that's yet another discrete state we need to model:<\/p>\n<pre><code class=\"language-mermaid\">stateDiagram-v2\n    [*] --&gt; Loading\n    Loading --&gt; Error\n    Loading --&gt; Success\n    Error --&gt; RefreshingFromError\n    RefreshingFromError --&gt; Error\n    RefreshingFromError --&gt; Success\n    Success --&gt; RefreshingFromSuccess\n    RefreshingFromSuccess --&gt; Error\n    RefreshingFromSuccess --&gt; Success\n<\/code><\/pre>\n<p>I hope you see where I'm going with this.<\/p>\n<p>The idea that a state is so easily mapped 1-1 to discrete values sounds great in theory, but doesn't hold up so well to\nreal-world, non-trivial use-cases. It's difficult to extend, leads to repetition, and you end up with a combinatorial\nmatrix of states that can quickly grow really complex. And while the sealed subclasses themselves model the discrete\nstates well, they actually do nothing to model the <em>transitions<\/em> between states. You can't use the type system to ensure\nyou don't move from one state to another, and if you need to move between states and carry the data with it (such as\nfrom <code>Success<\/code> to <code>RefreshingFromSuccess<\/code>), then you have to abuse the type system to perform type-checks or type-casts\nto actually make that transition.<\/p>\n<p>And finally, to drive the point home, let's consider what the actual UI code looks like here in this final case.\nAssuming we want to share the UI widgets whenever possible we get this:<\/p>\n<pre><code class=\"language-kotlin\">@Composable\nfun TrafficLight(state: TrafficLightState) {\n    // display progress bar in Loading or Refreshing states\n    if(state is Loading || state is RefreshingFromSuccess || state is RefreshingFromError) {\n        CircularProgressIndicator()\n    }\n\n    // display the traffic light color when it's available\n    val trafficLightColor: Color? = when(state) {\n        is Success -&gt; state.color\n        is RefreshingFromSuccess -&gt; state.color\n        else -&gt; null\n    }\n    if(trafficLightColor != null) {\n        TrafficLightColor(trafficLightColor)\n    }\n\n    // and a similar thing happens with the error text, except we just check types directly\n    if(state is Error || state is RefreshingFromError) {\n        TrafficLightError()\n    }\n}\n<\/code><\/pre>\n<p>Alternatively, you could have discrete <code>@Composable<\/code> functions for each discrete state, but then there's no UI\nconsistency between those states. If you make a change to one, you'd have to duplicate that change everywhere. Or if you\nkeep it in one function, as in the example above, you have to put in a ton of logic in the UI portion just to\naccommodate the discrete UI types, while still not really having discrete UIs for it.<\/p>\n<p>The linked article suggests that the sealed class is best because its cardinality (number of possible states) is 5 vs\n16 with a data class. But actually, if you expand the use-case to allow pull-to-refresh, the cardinality actually\nbecomes:<\/p>\n<pre><code>   1 Loading\n   1 Error\n   3 Success\n   1 RefreshingFromError\n + 3 RefreshingFromSuccess\n--------------------------\n   9 Total\n<\/code><\/pre>\n<p>Cardinality of 9 is still better than 16, but this is really broken up into 5 discrete cases, each of which must be\nhandled explicitly. In contrast, there's only 3 &quot;cases&quot; that need to be considered with the data class, and the implicit\ncombinations of those cases account for all 16 cardinal states. Additionally, you'd have to explicitly account for the\ntransitions between states, of which there are 8. So in all, there are 17 pieces of data that need to be managed\nexplicitly between the states and the transitions, versus 16 that are managed implicitly with a data class. Again, with\nsmall numbers of discrete states, this isn't necessarily a deal-breaker, but with larger complex screens it absolutely\nis. And making changes to the state of a data class will implicitly make the update everywhere needed, while those same\nchanges to sealed classes would need an exponentially large number of code updates to accommodate them with each\nsuccessive change.<\/p>\n<p>So again, while this style sounds great in theory, it really just doesn't hold up when put into real-world code.<\/p>\n<h4 id=\"data-class\"><a href=\"#data-class\" id=\"data-class\" class=\"anchor\"><\/a>Data Class<\/h4>\n<p>Whereas a <code>sealed class<\/code> maps well to discrete states but causes complexity when it comes to actually applying that to\nthe UI and its interactions, a <code>data class<\/code> does the opposite: you first think about the data you want to display on the\nUI, and you write your code to enforce the consistency of it. For example, the <a href=\"https://proandroiddev.com/modelling-ui-state-on-android-26314a5975b9\">Modelling UI State on Android<\/a>\narticle uses the following as an example of what not to do (and what I think you <em>should<\/em> do):<\/p>\n<pre><code class=\"language-kotlin\">data class TrafficLightState(\n    val isLoading: Boolean,\n    val isError: Boolean,\n    val color: Color?\n)\n<\/code><\/pre>\n<p>That article's argument against this state is that it has invalid states. For example, you could have <code>isError<\/code> true at\nthe same time that <code>color<\/code> is non-null, and what do you show in the UI at that point?<\/p>\n<p>The answer is pretty simple: just don't let that happen. Since it's a single object, you have full control over every\nproperty of it, and you can put that kind of logic directly within the class to ensure we never get a state that has\nboth data and an error:<\/p>\n<pre><code class=\"language-kotlin\">data class TrafficLightState(\n    val isLoading: Boolean,\n    val isError: Boolean,\n    val color: Color?\n) {\n    init {\n        if(isError &amp;&amp; color != null) {\n            throw IllegalStateException(&quot;error: cannot have both an error and color at the same time&quot;)\n        }\n    }\n}\n<\/code><\/pre>\n<p>Notice that with this 1 change, we can now model all potential use-cases from the <code>sealed class<\/code> scenario, even the\ncomplex transitions of pull-to-refresh:<\/p>\n<pre><code class=\"language-kotlin\">val Loading = TrafficLightState(\n    isLoading = true,\n    isError = false,\n    color = null,\n)\nval Error = TrafficLightState(\n    isLoading = false,\n    isError = true,\n    color = null,\n)\nval Success = TrafficLightState(\n    isLoading = false,\n    isError = false,\n    color = Color.Green,\n)\nval RefreshingAfterSuccess = TrafficLightState(\n    isLoading = true,\n    isError = false,\n    color = Color.Green,\n)\nval RefreshingAfterError = TrafficLightState(\n    isLoading = true,\n    isError = true,\n    color = null,\n)\n<\/code><\/pre>\n<p>Without making any changes to the state class itself, we were able to extend it to support the additional use-cases\nwithout adding any complexity to the screen. Furthermore, modeling the additional use-cases in the UI comes for free:\nby adding the code to do pull-to-refresh, all we need to do is <code>state.copy(isLoading = true)<\/code>, and whatever state we were\npreviously in, be it error or success, will be displayed properly in the UI. For example:<\/p>\n<pre><code class=\"language-kotlin\">@Composable\nfun TrafficLight(state: TrafficLightState) {\n    // display progress bar in Loading or Refreshing states\n    if(state.isLoading) {\n        CircularProgressIndicator()\n    }\n\n    // display the traffic light color when it's available\n    if(state.color != null) {\n        TrafficLightColor(state.color)\n    }\n\n    // and a similar thing happens with the error text, except we just check types directly\n    if(state.isError) {\n        TrafficLightError()\n    }\n}\n<\/code><\/pre>\n<p>So much cleaner than the version using a <code>sealed class<\/code>! When it comes down to it, it's the same exact UI, using the\nsame <code>if<\/code>-statements, but this is so much more readable. It's much easier to look at this code and figure out which\nproperties we need to set to get the UI to look a certain way, than if we were to model it with the sealed class. In\nreality, we don't care as much as having discrete UI states as we do <em>consistent<\/em> UI states. While the sealed class\napproach does give us incredibly consistent data models for the state, it doesn't actually produce a very consistent UI\nunless we do a lot of work to make it so. In contrast, data classes aren't as great as making a consistent model, but\nmake for a much more consistent UI, which is what the user is actually looking at and interacting with. And when using\nan MVI approach like Ballast to protect updates to the state, you can enforce the consistency of the state yourself just\nin how your make updates to it.<\/p>\n<p>Furthermore, this style is actually not completely divorced from sealed classes! You can use the <code>data class<\/code> as the\nmain state holder, and still define individual mutually-exlusive properties within that state as <code>sealed classes<\/code>, to\nget the same kind of benefit! These intermediary classes can be modeled with the built-in <code>Result<\/code> type, or you can\nwrite your own wrapper for a more domain-specific result. For example:<\/p>\n<pre><code class=\"language-kotlin\">data class TrafficLightState(\n    val isLoading: Boolean,\n    val color: Result&lt;Color&gt;?,\n)\n@Composable\nfun TrafficLight(state: TrafficLightState) {\n    if(state.isLoading) {\n        CircularProgressIndicator()\n    }\n\n    // state.color is null until loading hs completed, at which point it is either Success or Failure\n    state.color?.fold(\n        onSuccess = {\n            TrafficLightColor(it)\n        },\n        onFailure = {\n            TrafficLightError()\n        }\n    )\n}\n<\/code><\/pre>\n<h4 id=\"multiple-streams\"><a href=\"#multiple-streams\" id=\"multiple-streams\" class=\"anchor\"><\/a>Multiple Streams<\/h4>\n<p>The final approach to modeling a UI state isn't really even compatible with Ballast, but it's a pattern I see\nconsiderably less frequently now with <code>StateFlow<\/code> than I did in years-past when <code>LiveData<\/code> reigned supreme on Android.\nThe general idea was that instead of having a single stream of data representing your state as a single object (be it\na <code>sealed class<\/code> or a <code>data class<\/code>), the <code>ViewModel<\/code> itself is the UI state. Each property you want to expose to the UI\nis a separate reactive property, so that anything you want to update in the UI just needs to observe the appropriate\nproperty and react in kind:<\/p>\n<p>Also taking the example from <a href=\"https://proandroiddev.com/modelling-ui-state-on-android-26314a5975b9\">Modelling UI State on Android<\/a> (but replacing <code>LiveData<\/code> with <code>StateFlow<\/code>):<\/p>\n<pre><code class=\"language-kotlin\">class TrafficLightViewModel : ViewModel() {\n    private val _loading = mutableStateFlow&lt;Boolean&gt;(false)\n    private val _error = mutableStateFlow&lt;Boolean&gt;(false)\n    private val _color = mutableStateFlow&lt;Color?&gt;(null)\n\n    val loading: StateFlow&lt;Boolean&gt; get() = _loading.asStateFlow()\n    val error: StateFlow&lt;Boolean&gt; get() = _error.asStateFlow()\n    val color: StateFlow&lt;Color?&gt; get() = _color.asStateFlow()\n}\n<\/code><\/pre>\n<p>This effectively gives us the same type of UI code as with the <code>data class<\/code>, but we have lost control of any kind of\ncombination of values from within the data holder itself. We would have to combine the 3 values into a single stream\nin order to actually check that we don't get ourselves into an invalid state, which gets real ugly really quickly:<\/p>\n<pre><code class=\"language-kotlin\">class TrafficLightViewModel : ViewModel() {\n    private val _loading = mutableStateFlow&lt;Boolean&gt;(false)\n    private val _error = mutableStateFlow&lt;Boolean&gt;(false)\n    private val _color = mutableStateFlow&lt;Color?&gt;(null)\n\n    val loading: StateFlow&lt;Boolean&gt; get() = _loading.asStateFlow()\n    val error: StateFlow&lt;Boolean&gt; get() = _error.asStateFlow()\n    val color: StateFlow&lt;Color?&gt; get() = _color.asStateFlow()\n\n    init {\n        combine(error, color) { errorValue, colorValue -&gt; errorValue to colorValue }\n            .onEach { errorValue, colorValue -&gt;\n                if(errorValue &amp;&amp; colorValue != null) {\n                    throw IllegalStateException(&quot;error: cannot have both an error and color at the same time&quot;)\n                }\n            }\n            .launchIn(viewModelScope)\n    }\n}\n<\/code><\/pre>\n<p>Not only is this a lot of code needed to combine the values to check for illegal combinations, but we are forced to\nobserve those flows in a coroutine to check. This means that if we ever detect an invalid scenario, the stacktrace will\nonly point us to the flow itself, and really gives us no indication of which portion of our code actually set those\nproperties in an invalid way.<\/p>\n<p>In addition, there's not really any consistency between these values when we set them. If the code making the updates\nhappens to be a bit slow, the <code>combine<\/code> function may collect a pair of values that are invalid, without us actually\nintending to make that the UI state. The state just happened to be invalid as it transitioned.\nHaving to update the flows independently means there's no kind of &quot;transation&quot; that could be applied to ensure there's\nno ephemeral invalid states. But with a <code>data class<\/code>, a single <code>.update { it.copy() }<\/code> can freely change multiple\nproperties at once without causing there to be any invalid intermediate states.<\/p>\n<h2 id=\"async-logic\"><a href=\"#async-logic\" id=\"async-logic\" class=\"anchor\"><\/a>Async Logic<\/h2>\n<p>How to handle async logic within Ballast depends a bit on your specific needs, and will impact how Ballast requires you\nto write your code so that it is always handled safely. When working with Ballast, it is important to keep the following\n2 rules in mind:<\/p>\n<ol>\n<li>Only 1 Input will be processed at any given time<\/li>\n<li>Inputs are processed in parallel to the UI, not synchronously. So a new Input may be dispatched to the ViewModel\nwhile one is still running<\/li>\n<\/ol>\n<p>Ballast has several strategies to enforce these 2 rules and ensure they are well-behaved, or even allows you to customize\nits behavior to break the rules. But it's important to keep in mind these 2 rules and make sure you understand the\nconsequences of breaking them. Let's break these rules down and understand how they impact your app, by considering the\nfollowing example:<\/p>\n<p>We have 2 Inputs which load data from a remote API. Each Input sets <code>loading<\/code> to true until the API call returns, then\nsets it back to false along with its results. Individually, each Input is perfectly well-behaved, but things start to go\nwrong when we try to send both Inputs at the same time.<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.LoadPosts -&gt; {\n        updateState { it.copy(loading = true) }\n        val posts = postsRepository.getPosts() // suspending function, takes 2 seconds\n        updateState { it.copy(loading = false, posts = posts) }\n    }\n    is Inputs.LoadLatestPostContent -&gt; {\n        updateState { it.copy(loading = true) }\n        val latestPost = postsRepository.getLatestPost() // suspending function, takes 1 second\n        updateState { it.copy(loading = false, latestPost = latestPost) }\n    }\n}\n\nviewModel.trySend(Inputs.LoadPosts)\nviewModel.trySend(Inputs.LoadLatestPostContent)\n<\/code><\/pre>\n<p>If we consider the user's perspective, they should see a progress indicator displayed for 2 seconds, because that's how\nlong it takes to load the posts. The latest post loads more quickly than that, so we'd expect to display the progress\nindicator for as long as anything is still loading.<\/p>\n<p>But with this implementation, if we sent both Inputs at the same time and allowed them to run in parallel, the progress\nindicator would be dismissed after only 1 second, and 1 second after that the user would see an unpleasant &quot;jank&quot; as the\nlist of posts arrives unexpectedly.<\/p>\n<p>The following are some strategies we could employ to provide a better UX to the user, with their pros and cons<\/p>\n<h3 id=\"queue-up-the-inputs-and-run-them-1-at-a-time\"><a href=\"#queue-up-the-inputs-and-run-them-1-at-a-time\" id=\"queue-up-the-inputs-and-run-them-1-at-a-time\" class=\"anchor\"><\/a>Queue up the Inputs and run them 1 at a time<\/h3>\n<p>The first thing we could do is to make sure that only 1 Input is executing at a time. This would ensure no race\nconditions are possible from interleaved code, but it would also mean that this snippet now takes 3 seconds to complete,\ninstead of 2. It also leaves a tiny amount of time between when <code>LoadPosts<\/code> finished and sets <code>loading<\/code> to <code>false<\/code>, and\nwhen <code>LoadLatestPostContent<\/code> starts and sets it back to true. If the device is fast enough, the user might not notice,\nbut slower devices may result in the progress indicator being briefly dismissed, then shown again.<\/p>\n<p>This works to prevent the race conditions, but it introduces another problem: if the user doesn't actually want to see\nthese posts, and instead was just passing through this screen to get to another, they are stuck waiting for the whole\nthing to load anyway. Because the Inputs get queued up, the user's request to move to another screen will wait for the\nfirst two to complete before actually processing the navigation request. Obviously, this is not a great UX, and may\nleave the user frustrated with the slowness of the app.<\/p>\n<h3 id=\"cancel-inputs-so-only-the-latest-1-is-running-at-a-time\"><a href=\"#cancel-inputs-so-only-the-latest-1-is-running-at-a-time\" id=\"cancel-inputs-so-only-the-latest-1-is-running-at-a-time\" class=\"anchor\"><\/a>Cancel Inputs so only the latest 1 is running at a time<\/h3>\n<p>So we see that having only 1 Input run at a time is good, but the &quot;blocking&quot; queue is not. So instead, why don't we try\nonly processing the latest Input we receive at any given time? With Kotlin flows, this is done with the <code>.mapLatest { }<\/code>\noperator, and actually is the default strategy Ballast uses (though it can be changed).<\/p>\n<p>When using <code>.mapLatest { }<\/code>, if the UI is loading some data and the user requests to navigate away, the API calls will\nbe cancelled before they finish, so that Ballast can accept the latest Input and handle the navigation request\nimmediately.<\/p>\n<p>But this is not without its drawbacks either. Since we sent both &quot;initial&quot; Inputs at the same time, the second one will\nimmediately cancel the first. The result is a progress indicator that only displays for 1 second, and we load the latest\npost content but never get the full list of posts from the first Input. While this strategy does provide the best\nexperience to the user, it can be subtly confusing for developers, which is why it's best to structure your app such\nthat you don't encounter this situation.<\/p>\n<h3 id=\"use-a-single-initialize-input-to-perform-all-long-running-operations\"><a href=\"#use-a-single-initialize-input-to-perform-all-long-running-operations\" id=\"use-a-single-initialize-input-to-perform-all-long-running-operations\" class=\"anchor\"><\/a>Use a single &quot;Initialize&quot; Input to perform all long-running operations<\/h3>\n<p>One way to restructure your Inputs to avoid accidental cancellation is to move all long-running &quot;fetch&quot; operations into\na single Input, canonically called <code>Initialize<\/code>, and sending that 1 event when the screen starts instead of multiple for\nindividual resources.<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.Initialize -&gt; {\n        coroutineScope {\n            updateState { it.copy(loading = true) }\n            val deferredPosts = async { postsRepository.getPosts() } // suspending function, takes 2 seconds\n            val deferredLatestPost = async { postsRepository.getLatestPost() } // suspending function, takes 1 second\n            updateState { it.copy(loading = false, posts = deferredPosts.await(), latestPost = deferredLatestPost.await()) }\n        }\n    }\n}\n\nviewModel.trySend(Inputs.Initialize)\n<\/code><\/pre>\n<p>So far, this is definitely the best way to handle this logic. Since we're using coroutines, we can run the fetching\noperations each in parallel with <code>async { ... }.await()<\/code>, and set a single <code>loading<\/code> flag that works for both endpoints.\nThe result is both data sources are loaded, the progress indicator is visible for 2 seconds, and if the user navigates\naway these API calls will be cancelled and the navigation performed immediately.<\/p>\n<p>This is the preferred pattern for loading data asynchronously in Ballast. But there are a few other use-cases that we'll\nconsider in a later section.<\/p>\n<h2 id=\"side-jobs\"><a href=\"#side-jobs\" id=\"side-jobs\" class=\"anchor\"><\/a>Side-jobs<\/h2>\n<p>The above section on Async Logic works when you have individual &quot;resources&quot; you are loading, and are reasonably sure the\nonly way it could get cancelled is if the user intends for it to be cancelled, such as by navigating to another screen\nwhere we do not need those resources.<\/p>\n<p>But real-world applications aren't always that simple. One use-case is observing a stream of events (a Kotlin <code>Flow<\/code>) of\nsome data source, rather than a discrete suspending value. For example, rather than the respository directly delivering\nthe results of an API call, it may cache it, and send multiple emissions to notify of the cache status (see\n<a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Ballast Repository<\/a> module). Or you connect to the phone's GPS and receive an endless stream of GPS\ncoordinates you need to display on a map. We need a new strategy to handle this kind of use-case: a &quot;side-job&quot;.<\/p>\n<p>Until this point, we've been working with the notion that the InputHandler will suspend until the async work completes,\nand we considered what would happen if a new Input arrived while one was already suspended. But if we have a\npotentially-infinite data source, we obviously cannot connect to that directly within the InputHandler. Similarly, maybe\nwe have a situation where it's not feasible to move all initialization logic into a single Input, but we still want to\nload from multiple APIs in parallel. Both these can be accomplished by moving that work into a <code>sideJob { }<\/code> block.<\/p>\n<p>Side-jobs work kind-of like a &quot;thunk&quot; in Redux; they move async logic outside of the normal data flow of the\nViewModel, running fully parallel to it, but provide a handle back to the ViewModel where it can post one or more\nadditional Inputs with the results of its data. Since they're running parallel to the ViewModel, we cannot allow a\nsideJob to modify the <code>State<\/code>, otherwise we'd run into the same problem we had initially, so instead it needs to just\nsend requests back into the proper Input stream to be processed as any other Input, applying the results to the state\nwhen they are processed themselves.<\/p>\n<h3 id=\"basic-side-job-usage\"><a href=\"#basic-side-job-usage\" id=\"basic-side-job-usage\" class=\"anchor\"><\/a>Basic Side-job Usage<\/h3>\n<p>Rewriting the original snippet to load both posts in a sideJob would look like this:<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.PostsLoaded -&gt; { updateState { it.copy(posts = input.posts) } }\n    is Inputs.LatestPostContentLoaded -&gt; { updateState { it.copy(latestPost = input.latestPost) } }\n    is Inputs.LoadPosts -&gt; {\n        sideJob {\n            val posts = postsRepository.getPosts() // suspending function, takes 2 seconds\n            postInput(Inputs.PostsLoaded(posts))\n        }\n    }\n    is Inputs.LoadLatestPostContent -&gt; {\n        sideJob {\n            val latestPost = postsRepository.getLatestPost() // suspending function, takes 1 second\n            postInput(Inputs.LatestPostContentLoaded(latestPost))\n        }\n    }\n}\n\nviewModel.trySend(Inputs.LoadPosts)\nviewModel.trySend(Inputs.LoadLatestPostContent)\n<\/code><\/pre>\n<p>(I've gone ahead and removed the <code>loading<\/code> flag from these examples, as they will just get in the way of the intent of\nthese snippets from here on out.)<\/p>\n<p>This snippet <em>almost<\/em> works, but it's ignoring a small, but very important detail of sideJobs: they are restartable.\nThe lifecycle of each <code>sideJob { }<\/code> block still needs to be managed by Ballast, cancelled when the ViewModel is\ncancelled. However, since MVI is a declarative design pattern, it's reasonable to assume that one could &quot;force a\nrefresh&quot; simply by sending the same Input back to Ballast. With normal Input processing rules, that would cancel the\ncurrent Input and run the new one. But sideJobs break out of that cycle, and so Ballast requires each sideJob to\nhave a different &quot;key&quot;. If any Input tries to launch a sideJob with the same key, the old sideJob will be\ncancelled to accept the new one. This prevents multiple instances of the same block of code being run all in parallel if\nthe same Input is sent multiple times.<\/p>\n<p>So the fix is to just provide a key to the <code>sideJob<\/code> function:<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.PostsLoaded -&gt; { updateState { it.copy(posts = input.posts) } }\n    is Inputs.LatestPostContentLoaded -&gt; { updateState { it.copy(latestPost = input.latestPost) } }\n    is Inputs.LoadPosts -&gt; {\n        sideJob(&quot;LoadPosts&quot;) {\n            val posts = postsRepository.getPosts() // suspending function, takes 2 seconds\n            postInput(Inputs.PostsLoaded(posts))\n        }\n    }\n    is Inputs.LoadLatestPostContent -&gt; {\n        sideJob(&quot;LoadLatestPostContent&quot;) {\n            val latestPost = postsRepository.getLatestPost() // suspending function, takes 1 second\n            postInput(Inputs.LatestPostContentLoaded(latestPost))\n        }\n    }\n}\n\nviewModel.trySend(Inputs.LoadPosts)\nviewModel.trySend(Inputs.LoadLatestPostContent)\n\nrefreshButton.setOnClickListener {\n    viewModel.trySend(Inputs.LoadPosts)\n    viewModel.trySend(Inputs.LoadLatestPostContent)\n}\n<\/code><\/pre>\n<h3 id=\"observing-flows\"><a href=\"#observing-flows\" id=\"observing-flows\" class=\"anchor\"><\/a>Observing Flows<\/h3>\n<p>Now that we have a basic idea of sideJobs, let's apply it to the use-case of observing GPS coordinates from your\nphone's sensor. Since sideJobs do not block the normal Input stream, there's nothing wrong with observing an infinite\nstream of events in it, so it becomes a simple matter of collecting from the <code>Flow<\/code> and posting all those changes back\nto the ViewModel.<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.GpsCoordinatesUpdated -&gt; { updateState { it.copy(coordinates = input.coordinates) } }\n    is Inputs.ObserveGpsSignal -&gt; {\n        sideJob(&quot;ObserveGpsSignal&quot;) {\n            gpsRepository\n                .observeLocation() // returns a Flow\n                .map { Inputs.GpsCoordinatesUpdated(it) }\n                .onEach { postInput(it) }\n                .launchIn(this)\n        }\n    }\n}\n\nviewModel.trySend(Inputs.ObserveGpsSignal)\n<\/code><\/pre>\n<p>As this is one of the main use-cases for sideJobs, and Ballast offers a convenient shorthand for you:<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.GpsCoordinatesUpdated -&gt; { updateState { it.copy(coordinates = input.coordinates) } }\n    is Inputs.ObserveGpsSignal -&gt; {\n        observeFlows(\n            gpsRepository\n                .observeLocation() // returns a Flow\n                .map { Inputs.GpsCoordinatesUpdated(it) },\n            key = &quot;ObserveGpsSignal&quot;\n        )\n    }\n}\n\nviewModel.trySend(Inputs.ObserveGpsSignal)\n<\/code><\/pre>\n<h3 id=\"sending-follow-up-inputs\"><a href=\"#sending-follow-up-inputs\" id=\"sending-follow-up-inputs\" class=\"anchor\"><\/a>Sending Follow-up Inputs<\/h3>\n<p>One final use-case for sideJobs that I haven't yet touched on is sending Inputs, without any further logic.<\/p>\n<p>Consider a pub-sub type architecture, where one Input needs to do some processing, and then dispatch another Input after\nit has finished. Attempting to send a new Input directly from another Input is bad for 2 potential reasons: immediate\ncancellation, or deadlock.<\/p>\n<p>The most likely scenario is that the Input Channel to the ViewModel is buffered. If we allowed an Input to directly send\nanother Input, then it will immediately get accepted, and thus cancel the current (sending) Input. But if the Channel\nwas configured to be <code>RENDEZVOUS<\/code> and running in a single-threaded coroutineContext, then the sender would suspend until\nthat Input is read from the channel, but the ViewModel will not able to receive the Input from that channel until the\nsender has finished, which is a deadlock. These are both hypothetical scenarios, but the danger is certainly there,\nwhich is why Ballast simply forbids sending an Input directly from another Input. Instead, Inputs can only be sent back\nto the ViewModel from a sideJob or an Event.<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.RequestLogout -&gt; {\n        loginRepository.logOut()\n        sideJob(&quot;RequestLogOut&quot;) {\n            postInput(Inputs.ClearCache)\n        }\n    }\n    is Inputs.ClearCache -&gt; {\n        updateState { it.copy(user = null) }\n    }\n}\n\nviewModel.trySend(Inputs.RequestLogout)\n<\/code><\/pre>\n<p>Like <code>observeFlows<\/code>, this too, has a convenient helper method which makes it look like you are sending an Input directly\nfrom another Input, but is in fact sending it from a sideJob block. Since it's a simple sideJob, it will also\nderive a key for you based on the Input (it's <code>.toString()<\/code>), so that calling <code>postInput()<\/code> does not accidentally cancel\nany other sideJobs.<\/p>\n<pre><code class=\"language-kotlin\">suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(input: Inputs) = when(input) {\n    is Inputs.RequestLogout -&gt; {\n        loginRepository.logOut()\n        postInput(Inputs.ClearCache)\n    }\n    is Inputs.ClearCache -&gt; {\n        updateState { it.copy(user = null) }\n    }\n}\n\nviewModel.trySend(Inputs.RequestLogout)\n<\/code><\/pre>\n"
        }]
      },
      "roadmap": {
        "ownKey": "roadmap",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "roadmap",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/roadmap"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "changelog",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/changelog"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "feature-comparison",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/feature-comparison"
          },
          "description": "",
          "title": "Roadmap",
          "content": "<h1 id=\"ballast-roadmap\"><a href=\"#ballast-roadmap\" id=\"ballast-roadmap\" class=\"anchor\"><\/a>Ballast Roadmap<\/h1>\n<p>The core Ballast functionality is now stable since 1.0.0 and will be maintained through Semantic Versioning and enforced\nwith <a href=\"https://github.com/Kotlin/binary-compatibility-validator\">Kotlin Binary Compatibility Validator<\/a>. The API of additional features will also be maintained, but there's\nstill a lot of functionality that could be added.<\/p>\n<p>The following are some ideas of what could be done with Ballast and its Interceptor API, though nothing on this list is\nan actual hard commitment to being developed. If you see an idea on this like you want, by all means, go build it\nyourself! I will gladly accept any contribution as a PR, or if you would rather develop the feature in a separate repo\nI will happily link to that repo from the Ballast documentation.<\/p>\n<ul>\n<li><a href=\"https://github.com/copper-leaf/ballast/issues/2\">Synchrony Module<\/a>: Synchronize the VM state between multiple clients over a network connection, for building\nrealtime multi-user applications<\/li>\n<li><a href=\"https://github.com/copper-leaf/ballast/issues/7\">Finite State Machine DSL<\/a>: Ballast is basically an FSM already, and it would be nice to build a dedicated DSL\nlike <a href=\"https://github.com/Tinder/StateMachine\">Tinder/StateMachine<\/a> on top of Ballast so it could be used on any Kotlin target<\/li>\n<li><a href=\"https://github.com/copper-leaf/ballast/issues/10\">Undo/redo functionality<\/a>: An undo/redo controller that tracks &quot;frames&quot; for when Inputs are processed, and move\nforward/backward through those frames to restore the ViewModel to that point in time<\/li>\n<\/ul>\n"
        }]
      },
      "usage-guide": {
        "ownKey": "usage-guide",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "usage-guide",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/usage-guide"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "platforms",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/platforms"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "mental-model",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/mental-model"
          },
          "description": "",
          "title": "Usage Guide",
          "content": "<h1 id=\"usage-guide\"><a href=\"#usage-guide\" id=\"usage-guide\" class=\"anchor\"><\/a>Usage Guide<\/h1>\n<p>Ballast is an opinionated library, and it was carefully designed to give you a standard workflow for all types of\nscreens or components in your application, and on any platform.<\/p>\n<p>Each platform will have some of its own special setup that may be needed, but the general workflow will be the same, as\noutlined here. This guide will cover the basics of getting set up and productive with Ballast, and will try to avoid\nany platform-specific functionality, or provide examples for multiple platforms to help you understand the workflow more\ngenerally. Refer to each individual <a href=\"https://copper-leaf.github.io/ballast/wiki/platforms\">Platform<\/a> for further instructions necessary for that platform.<\/p>\n<h2 id=\"high-level-workflow\"><a href=\"#high-level-workflow\" id=\"high-level-workflow\" class=\"anchor\"><\/a>High-level Workflow<\/h2>\n<p>The general workflow for Ballast involves the following steps:<\/p>\n<ol>\n<li>Define a Contract<\/li>\n<li>Write the InputHandler<\/li>\n<li>Write the EventHandler<\/li>\n<li>Combine everything into a ViewModel<\/li>\n<li>Inject the ViewModel to your UI and start using it<\/li>\n<\/ol>\n<p>These steps are described in more depth <a href=\"#Ballast-Workflow\">below<\/a>, and while this workflow does involve a bit of\nboilerplate the <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-intellij-plugin\">Intellij plugin<\/a> can help you in quickly scaffolding out all of these classes.<\/p>\n<h2 id=\"project-architecture\"><a href=\"#project-architecture\" id=\"project-architecture\" class=\"anchor\"><\/a>Project Architecture<\/h2>\n<p>Ballast generally works best as part of a layered architecture, consisting of the following layers:<\/p>\n<h3 id=\"ui\"><a href=\"#ui\" id=\"ui\" class=\"anchor\"><\/a>UI<\/h3>\n<p>At the UI layer, you will have things broken up into Screens or Components per your own requirements, and these UI\npieces should be a &quot;reactive&quot; UI. This basically means that the entire UI for that screen is driven from a State object,\nand the entire UI is updated whenever any part of the State changes. Frameworks like Compose or React were obviously\nbuilt to apply these updates efficiently, but non-reactive UI frameworks can be adapted to this pattern fairly easily,\nso using a &quot;reactive UI framework&quot; is not necessary to use Ballast.<\/p>\n<p>Note that &quot;screens&quot; is primarily referring to a Mobile form-factor, while &quot;components&quot; refers more to Desktop or Web.\nAlso a &quot;component&quot; as used in this guide would be a bigger, more complex chunk of UI than just a React component, for\nexample. Think of components basically as a small portion of the entire Web/Desktop screen that is basically its own\nfeature, such as a data table with all the filtering capabilities or a tool panel in an IDE, something that would\nbasically need to be its own screen on a mobile device.<\/p>\n<h3 id=\"viewmodel\"><a href=\"#viewmodel\" id=\"viewmodel\" class=\"anchor\"><\/a>ViewModel<\/h3>\n<p>Since each screen/component is reactive and driven by a State, you need something to manage that State, which we call a\nViewModel. The purpose of the ViewModel is to live <em>at least<\/em> as long as the Screen (potentially longer depending on\nplatform implementation), and be the class to hold and update the State, dispatching changes back to the UI.<\/p>\n<p>There should be a 1-to-1 relationship between screens and ViewModels. Each screen should really only be observing a\nsingle ViewModel, and each ViewModel should not be shared between different screens. If data should be shared between\nmultiple screens/components it should either be passed from one to the other during navigation, or else managed in the\nRepository layer and observed from both screen's ViewModels.<\/p>\n<p>This is the layer that Ballast was primarily designed to implement.<\/p>\n<h3 id=\"repository\"><a href=\"#repository\" id=\"repository\" class=\"anchor\"><\/a>Repository<\/h3>\n<p>The data stored in each screen's ViewModel is really just the local state for that screen, divorced from any persistent\napplication state. It only knows what is directly needed for that one screen, but there will be a lot more data needed\nin an application than just what is visible on the screen. For example, account session tokens, profile information,\nuser preferences, and other data like that will necessarily live much longer than a single screen, and likely needs to\nbe shared among different screens (potentially at the same time).<\/p>\n<p>The Repository layer's job is to manage all that data and expose a clean interface to the ViewModels that abstracts away\nthe complexity of those underlying data sources. The Repository layer shouldn't expose database or API models directly\nto the ViewModel, because those structures are likely to change or use &quot;unsafe&quot; values (nulls,\n<a href=\"https://wiki.c2.com/?StringlyTyped\">stringly-typed values<\/a>, etc). Instead, it should map those models to safer ones that are easier to work with in the\nUI (by parsing Strings into the proper enums, providing default values for nulls, etc.), thereby isolating the UI from\nchanges to the API or database structure.<\/p>\n<p>By its nature, the Repository layer can be a bit precarious to work on, because one change can affect many parts of your\napplication. It's also largely an exercise in caching, which we all know is a <a href=\"https://martinfowler.com/bliki/TwoHardThings.html\">hard problem<\/a>. Traditionally, the\nlibraries and code that implemented the repository layer was very different from the ViewModel layer, but Ballast's\n<a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Repository module<\/a> allows you to use the same mental model for building both, reducing the difficulty of\ncontext-switching and making the repository layer less intimidating and easier to understand and work with.<\/p>\n<h3 id=\"final-thoughts-on-architecture\"><a href=\"#final-thoughts-on-architecture\" id=\"final-thoughts-on-architecture\" class=\"anchor\"><\/a>Final Thoughts on Architecture<\/h3>\n<p>You'll notice that this layering does not describe any kind of &quot;API layer&quot; or &quot;Database layer&quot;, and that is intentional.\nIt's best to think of those not as discrete layers, but rather just as data sources that are exposed through the\nRepository layer. If you think of the API or Database as a &quot;layer&quot;, you will naturally want to conform your application\nto the structure of those, which will cause problems if there are any major changes needed in them later on. Instead,\njust build your app using models you define that are easy to work with, and use the Repository layer to conform the API\nto the structure of your application.<\/p>\n<p>And finally, here's a diagram showing an example application designed with this architecture. Consider a basic TODO app\nthat users must log-in to use.<\/p>\n<pre><code class=\"language-mermaid\">flowchart TD\n    subgraph UI\n        Login[Login Screen]\n        Registration[Registration Screen]\n        ToDoList[ToDo List Screen]\n        ToDoDetails[ToDo Details Screen]\n    end\n\n    subgraph ViewModel\n        LoginVm[LoginViewModel]\n        RegistrationVm[RegistrationViewModel]\n        ToDoListVm[ToDoListViewModel]\n        ToDoDetailsVm[ToDoDetailsViewModel]\n    end\n\n    subgraph Repository\n        AccountRepository[AccountRepository]\n        RegistrationRepository[RegistrationRepository]\n        ToDoRepository[ToDoRepository]\n    end\n\n    ToDoDb[(Local ToDo Database)]\n    ToDoApi(ToDo API)\n    AuthProvider(Authentication Provider)\n\n    ToDoDb&lt;--&gt;ToDoRepository\n    ToDoApi&lt;--&gt;ToDoRepository\n\n    AuthProvider&lt;--&gt;AccountRepository\n    AuthProvider&lt;--&gt;RegistrationRepository\n\n    RegistrationRepository&lt;--&gt;RegistrationVm\n\n    AccountRepository&lt;--&gt;LoginVm\n    AccountRepository&lt;--&gt;ToDoListVm\n    AccountRepository&lt;--&gt;ToDoDetailsVm\n\n    ToDoRepository&lt;--&gt;ToDoListVm\n    ToDoRepository&lt;--&gt;ToDoDetailsVm\n\n    LoginVm--States--&gt;Login\n    Login--Inputs--&gt;LoginVm\n    \n    RegistrationVm--States--&gt;Registration\n    Registration--Inputs--&gt;RegistrationVm\n    \n    ToDoListVm--States--&gt;ToDoList\n    ToDoList--Inputs--&gt;ToDoListVm\n    \n    ToDoDetailsVm--States--&gt;ToDoDetails\n    ToDoDetails--Inputs--&gt;ToDoDetailsVm\n<\/code><\/pre>\n<h2 id=\"ballast-workflow\"><a href=\"#ballast-workflow\" id=\"ballast-workflow\" class=\"anchor\"><\/a>Ballast Workflow<\/h2>\n<p>This section goes more in-depth into the individual components needed for the full Ballast Workflow. For a quick,\nhigh-level listing of the classes needed, see <a href=\"#high-level-workflow\">High-level Workflow<\/a>.<\/p>\n<h3 id=\"define-a-contract\"><a href=\"#define-a-contract\" id=\"define-a-contract\" class=\"anchor\"><\/a>Define a Contract<\/h3>\n<p>The first step for using Ballast on any screen is to define the Contract. The Contract provides a structure for what\ndata will be changing in your screen (the State), and how you will be interacting with it (Inputs), which gives you a\nsingle place to go to understand everything you need to know about any given screen. By having a dedicated Contract, you\nwon't have any hidden or undocumented functionality that is difficult to reproduce.<\/p>\n<p>If you're using Ballast in a multiplatform project, the Contract should be in the <code>commonMain<\/code> sourceSet.<\/p>\n<p>See more about defining your contract in <a href=\"https://copper-leaf.github.io/ballast/wiki/mental-model#UI Contract\">Thinking in Ballast MVI<\/a>.<\/p>\n<pre><code class=\"language-kotlin\">object LoginScreenContract {\n    data class State(\n        val username: TextFieldValue,\n        val password: TextFieldValue,\n    )\n\n    sealed class Inputs {\n        data class UsernameChanged(val newValue: TextFieldValue) : Inputs()\n        data class PasswordChanged(val newValue: TextFieldValue) : Inputs()\n        object LoginButtonClicked : Inputs()\n        object RegisterButtonClicked : Inputs()\n    }\n\n    sealed class Events {\n        object NavigateToDashboard : Events()\n        object NavigateToRegistration : Events()\n    }\n}\n<\/code><\/pre>\n<h3 id=\"write-the-inputhandler\"><a href=\"#write-the-inputhandler\" id=\"write-the-inputhandler\" class=\"anchor\"><\/a>Write the InputHandler<\/h3>\n<p>After defining the contract, you should then write the InputHandler to process the Inputs as they are received. The\nInputHandler is the class that will be talking to your Repository layer, so any necessary Repositories should be\nprovided through the InputHandler's contructor<\/p>\n<p>If you're using Ballast in a multiplatform project, the InputHandler should be in the <code>commonMain<\/code> sourceSet.<\/p>\n<p>See more about writing your InputHandler in <a href=\"https://copper-leaf.github.io/ballast/wiki/feature-overview#Input Handlers\">Features<\/a>.<\/p>\n<pre><code class=\"language-kotlin\">import LoginScreenContract.*\n\nclass LoginScreenInputHandler(\n    private val loginRepository: LoginRepository,\n) : InputHandler&lt;Inputs, Events, State&gt; {\n    override suspend fun InputHandlerScope&lt;Inputs, Events, State&gt;.handleInput(\n        input: Inputs\n    ) = when (input) {\n        is UsernameChanged -&gt; { }\n        is PasswordChanged -&gt; { }\n        is LoginButtonClicked -&gt; { }\n        is RegisterButtonClicked -&gt; { }\n    }\n}\n<\/code><\/pre>\n<h3 id=\"connect-to-the-platform-ui\"><a href=\"#connect-to-the-platform-ui\" id=\"connect-to-the-platform-ui\" class=\"anchor\"><\/a>Connect to the Platform UI<\/h3>\n<p>The last step is to actually use Ballast to build out your interactive UI. This typically involves several steps that\nwill all be specific to the target you're running Ballast on, but compared to the effort involved with the Contract and\nInputHandler, are relatively simple. So even though there is some platform-specific functionality you'll need to write,\nyou will still be sharing the majority of the business-logic code in your application.<\/p>\n<p>If you are using Ballast in a multiplatform application, the following pieces will typically be defined in the\nplatform-specific sourceSets rather than in <code>commonMain<\/code>.<\/p>\n<h4 id=\"viewmodel-1\"><a href=\"#viewmodel-1\" id=\"viewmodel-1\" class=\"anchor\"><\/a>ViewModel<\/h4>\n<p>The first step is to define the ViewModel class for each <a href=\"https://copper-leaf.github.io/ballast/wiki/platforms\">platform<\/a>. This will vary slightly depending on which\nplatform you target, so that the ViewModel integrates well with the platform's normal lifecycle. For example, on\nAndroid, you'll make your screen's ViewModel extend <code>AndroidViewModel<\/code>, which is an instance of\n<code>androidx.lifecycle.ViewModel<\/code> that can be provided via Hilt or Navigation-Compose. For platforms that don't have their\nown specific ViewModel implementation, or for use-cases where you want to manually control the ViewModel's lifecycle\nthrough a <code>CoroutineScope<\/code>, you can use <code>BasicViewModel<\/code> as the base class.<\/p>\n<p>All ViewModel implementations will look pretty similar, regardless of the base class used. You'll need to create a\n<code>BallastViewModelConfiguration<\/code> and pass it to the base class's constructor, along with any additional parameters needed\nfor the specific implementation, if any (for example, the <code>CoroutineScope<\/code> of a <code>BasicViewModel<\/code>). This is easiest to\ndo with <code>BallastViewModelConfiguration.Builder<\/code>, but you can also structure everything with Dependency Injection, too\n(see section below on <a href=\"#dependency-injection\">Dependency Injection<\/a>). The <code>BallastViewModelConfiguration.Builder<\/code> is\nwhere you will specify the InputHandler and initial State for the ViewModel, as well as providing other more generic\nconfiguration such as loggers or interceptors.<\/p>\n<p>Despite each platform's native ViewModel being named the same and looking very similar, you typically wouldn't define it\nwith <code>actual/expect<\/code> declarations in a multiplatform project because there's usually no need to share the ViewModel\nitself in common code, so it just creates unnecessary overhead. Furthermore, the base classes for each platform\ntypically have different constructors, so it's difficult to provide an <code>actual/expect<\/code> that is actually useful in common\ncode for simplifying any DI. It's best to just provide the ViewModel implementations from the platform-specific DI\nmodules.<\/p>\n<pre><code class=\"language-kotlin\">// androidMain/ui/login/LoginScreenViewModel.kt\nclass LoginScreenViewModel() : AndroidViewModel&lt;\n    LoginScreenContract.Inputs,\n    LoginScreenContract.Events,\n    LoginScreenContract.State&gt;(\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            this += LoggingInterceptor()\n            logger = { AndroidBallastLogger(it) }\n        }\n        .forViewModel(\n            initialState = LoginScreenContract.State(),\n            inputHandler = LoginScreenInputHandler(),\n            name = &quot;LoginScreen&quot;,\n        )\n)\n\n// jsMain/ui/login/LoginScreenViewModel.kt\nclass LoginScreenViewModel(\n    viewModelCoroutineScope: CoroutineScope\n) : BasicViewModel&lt;\n    LoginScreenContract.Inputs,\n    LoginScreenContract.Events,\n    LoginScreenContract.State&gt;(\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            this += LoggingInterceptor()\n            logger = { JsConsoleBallastLogger(it) }\n        }\n        .forViewModel(\n            initialState = LoginScreenContract.State(),\n            inputHandler = LoginScreenInputHandler(),\n            name = &quot;LoginScreen&quot;,\n        ),\n    eventHandler = LoginScreenEventHandler(),\n    coroutineScope = viewModelCoroutineScope,\n)\n<\/code><\/pre>\n<h4 id=\"eventhandler\"><a href=\"#eventhandler\" id=\"eventhandler\" class=\"anchor\"><\/a>EventHandler<\/h4>\n<p>The next step is to define an <code>EventHandler<\/code> for your ViewModel. The implementation will look very similar to an\nInputHandler, except that it will typically need a different implementation on each platform for handling things like\nnavigation requests (though this may not always be the case if you have your routing/navigation implemented entirely in\ncommon code).<\/p>\n<pre><code class=\"language-kotlin\">import LoginScreenContract.*\n\nclass LoginScreenEventHandler : EventHandler&lt;Inputs, Events, State&gt; {\n    override suspend fun EventHandlerScope&lt;Inputs, Events, State&gt;.handleEvent(\n        event: Events\n    ) = when (event) {\n        is Events.Notification -&gt; { }\n    }\n}\n<\/code><\/pre>\n<p>You may have noticed from the example ViewModel code above that the <code>BasicViewModel<\/code> has you providing the EventHandler\ndirectly in its constructor, while the <code>AndroidViewModel<\/code> does not. This is because EventHandlers are closely related to\nthe lifecycle of the ViewModel, but don't necessarily follow the exact same lifecycle. The EventHandler typically lives\nas long as the screen is active, but the ViewModel itself may be retained across multiple times of the screen being\nstopped and started.<\/p>\n<p>For a <code>BasicViewModel<\/code>, the lifecycle of the Screen, ViewModel, and EventHandler are all the same, and they're all\ncontrolled by the lifetime of the <code>CoroutineScope<\/code>. When moving to a new screen, the screen's <code>CoroutineScope<\/code> is\ncancelled, the ViewModel's processing is stopped, and the EventHandler detached. For this reason, the <code>EventHandler<\/code> is\nprovided through the <code>BasicViewModel<\/code>'s constructor, to make sure they all respect the same lifecycle.<\/p>\n<p>But on Android, it is not possible to use Hilt to inject a ViewModel with anything that depends on the Activity, since a\nViewModel lives longer than the Activity. Since the <code>EventHandler<\/code> is commonly used for handling Navigation requests,\nand navigation is done by the activity through <code>Activity.startActivity()<\/code> or <code>findNavController().navigate()<\/code>, it is\nimpossible to inject the <code>EventHandler<\/code> directly into the ViewModel, but instead it must be attached dynamically after\nthe ViewModel has been injected. See the <a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/android\">Android platform page<\/a> for specific instructions.<\/p>\n<h4 id=\"ui-1\"><a href=\"#ui-1\" id=\"ui-1\" class=\"anchor\"><\/a>UI<\/h4>\n<p>The final piece of the Ballast puzzle is actually defining your UI given the Ballast State. This typically involves\ncreating or accessing an instance of your ViewModel and observing its State as a <code>StateFlow<\/code> with\n<code>viewModel.observeStates()<\/code>. On each emission of that StateFlow, you will update the entire UI of the screen with the\nnew State, as per for the platform-specific requirements.<\/p>\n<p>On platforms that require the native programming language to use rather than Kotlin (SwiftUI, for example), there may be\nsome boilerplate needed to wrap the Kotlin coroutines and <code>StateFlow<\/code> into something that the platform's native code can\nintegrate with. But on Android, and using Compose for Desktop or Web, this is easily done in Kotlin. See each\n<a href=\"https://copper-leaf.github.io/ballast/wiki/platforms\">platform's<\/a> instructions for how to connect to the actual UI toolkit.<\/p>\n<h2 id=\"dependency-injection\"><a href=\"#dependency-injection\" id=\"dependency-injection\" class=\"anchor\"><\/a>Dependency Injection<\/h2>\n<p>Most apps will use some kind of DI, and Ballast is set up very well to provide all the necessary pieces via DI. Some of\nthe classes, especially the InputHandler, can typically be provided in common code, but other classes, like the\nViewModel or EventHandler, must be provided in the platform-specific modules.<\/p>\n<p>The best way to save time and LOC with DI is to provide a common definition of <code>BallastViewModelConfiguration.Builder<\/code>\nwith the configuration common to all ViewModels (the Logging and Debugger Interceptors, for example), and then using\nthat common builder to create the actual configuration for each ViewModel. Rewriting the ViewModel class to be setup\nwith DI might look something like this:<\/p>\n<pre><code class=\"language-kotlin\">class LoginScreenViewModel(\n    config: BallastViewModelConfiguration&lt;\n        LoginScreenContract.Inputs,\n        LoginScreenContract.Events,\n        LoginScreenContract.State&gt;,\n) : AndroidViewModel&lt;\n    LoginScreenContract.Inputs,\n    LoginScreenContract.Events,\n    LoginScreenContract.State&gt;(\n    config = config\n)\n<\/code><\/pre>\n<p>Using Koin on Android, the DI might look like this:<\/p>\n<pre><code class=\"language-kotlin\">val platformModule = module {\n    factory&lt;LoginApi&gt; {\n        LoginApiImpl()\n    }\n    single&lt;LoginRepository&gt; {\n        LoginRepositoryImpl(\n            loginApi = get()\n        )\n    }\n    factory&lt;BallastViewModelConfiguration.Builder&gt; {\n        BallastViewModelConfiguration.Builder()\n            .apply {\n                this += LoggingInterceptor()\n                logger = { AndroidBallastLogger(it) }\n            }\n    }\n    factory&lt;LoginScreenInputHandler&gt; {\n        LoginScreenInputHandler(\n            loginRepository = get()\n        )\n    }\n    viewModel&lt;LoginScreenViewModel&gt; { \n        LoginScreenViewModel(\n            config = get&lt;BallastViewModelConfiguration.Builder&gt;()\n                .forViewModel(\n                    initialState = LoginScreenContract.State(),\n                    inputHandler = get&lt;LoginScreenInputHandler&gt;(),\n                    name = &quot;LoginScreen&quot;,\n                ),\n        ) \n    }\n}\n\nclass LoginActivity : AppCompatActivity(), KoinComponent {\n    private val viewModel: LoginScreenViewModel by viewModel()\n}\n<\/code><\/pre>\n<p>For some platforms, you will need to provide parameters from the UI when accessing the ViewModel instance, such as a\n<code>CoroutineScope<\/code>. This is done through assisted injection. Again using Koin, this is what this would look like for JS:<\/p>\n<pre><code class=\"language-kotlin\">val platformModule = module {\n    factory&lt;LoginApi&gt; {\n        LoginApiImpl()\n    }\n    single&lt;LoginRepository&gt; {\n        LoginRepositoryImpl(\n            loginApi = get()\n        )\n    }\n    factory&lt;BallastViewModelConfiguration.Builder&gt; {\n        BallastViewModelConfiguration.Builder()\n            .apply {\n                this += LoggingInterceptor()\n                logger = { JsConsoleBallastLogger(it) }\n            }\n    }\n    factory&lt;LoginScreenInputHandler&gt; {\n        LoginScreenInputHandler(\n            loginRepository = get()\n        )\n    }\n    factory&lt;LoginScreenViewModel&gt; { (coroutineScope: CoroutineScope) -&gt;\n        LoginScreenViewModel(\n            config = get&lt;BallastViewModelConfiguration.Builder&gt;()\n                .forViewModel(\n                    initialState = LoginScreenContract.State(),\n                    inputHandler = get&lt;LoginScreenInputHandler&gt;(),\n                    name = &quot;LoginScreen&quot;,\n                ),\n        ) \n    }\n}\n\nclass LoginPage : KoinComponent {\n    @Composable\n    fun LoginContent() {\n        val viewModelScope = rememberCoroutineScope()\n        val viewModel: LoginScreenViewModel = remember(viewModelScope) { get { parametersOf(viewModelScope) } }\n    }\n}\n<\/code><\/pre>\n<p>Of course, it is possible to use Ballast with any other DI tool out there as well, such as Dagger/Hilt, Kodein, or even\nhand-written DI. The process for using any of those options will be very similar, just using that tool's specific DSL\nfor providing and accessing instances of each class.<\/p>\n<h2 id=\"folder-structure\"><a href=\"#folder-structure\" id=\"folder-structure\" class=\"anchor\"><\/a>Folder Structure<\/h2>\n<p>It's best to structure your applications such that each screen is in its own subfolder of <code>ui/<\/code>, which contains all of\nthe relevant classes for both Ballast and the UI. Likewise, each Repository should be in its own folder of\n<code>repository/<\/code>.<\/p>\n<p>For example, in a pure-Android application, the <a href=\"https://copper-leaf.github.io/ballast/wiki/examples\">four examples<\/a> would\nbe structured like this:<\/p>\n<pre><code>app/\n└── src/main/kotlin/\n    ├── api/\n    │   └── bgg/\n    │       └── BggApi.kt\n    ├── repository/\n    │   └── bgg/\n    │       ├── BggRepository.kt\n    │       ├── BggRepositoryImpl.kt\n    │       ├── BggRepositoryContract.kt\n    │       └── BggRepositoryInputHandler.kt\n    ├── ui/\n    │   ├── counter/\n    │   │   ├── CounterContract.kt\n    │   │   ├── CounterInputHandler.kt\n    │   │   ├── CounterEventHandler.kt\n    │   │   ├── CounterViewModel.kt\n    │   │   └── CounterFragment.kt\n    │   ├── scorekeeper/\n    │   │   ├── ScorekeeperContract.kt\n    │   │   ├── ScorekeeperInputHandler.kt\n    │   │   ├── ScorekeeperEventHandler.kt\n    │   │   ├── ScorekeeperViewModel.kt\n    │   │   └── ScorekeeperFragment.kt\n    │   ├── bgg/\n    │   │   ├── BggContract.kt\n    │   │   ├── BggInputHandler.kt\n    │   │   ├── BggEventHandler.kt\n    │   │   ├── BggViewModel.kt\n    │   │   └── BggFragment.kt\n    │   └── kitchensink/\n    │       ├── KitchenSinkContract.kt\n    │       ├── KitchenSinkInputHandler.kt\n    │       ├── KitchenSinkEventHandler.kt\n    │       ├── KitchenSinkViewModel.kt\n    │       └── KitchenSinkFragment.kt\n    ├── MainApplication.kt\n    └── MainActivity.kt\n<\/code><\/pre>\n<p>When using Ballast in a multiplatform app, the folder structure will not change, but you will have some of those classes\nmoved between the different sourceSets, as needed for each platform.<\/p>\n<pre><code>app/\n├── src/commonMain/kotlin/\n│   ├── api/\n│   │   └── bgg/\n│   │       └── BggApi.kt\n│   ├── repository/\n│   │   └── bgg/\n│   │       ├── BggRepository.kt\n│   │       ├── BggRepositoryImpl.kt\n│   │       ├── BggRepositoryContract.kt\n│   │       └── BggRepositoryInputHandler.kt\n│   └── ui/\n│       ├── counter/\n│       │   ├── CounterContract.kt\n│       │   └── CounterInputHandler.kt\n│       ├── scorekeeper/\n│       │   ├── ScorekeeperContract.kt\n│       │   └── ScorekeeperInputHandler.kt\n│       ├── bgg/\n│       │   ├── BggContract.kt\n│       │   └── BggInputHandler.kt\n│       └── kitchensink/\n│           ├── KitchenSinkContract.kt\n│           └── KitchenSinkInputHandler.kt\n├── src/androidMain/kotlin/\n│   ├── ui/\n│   │   ├── counter/\n│   │   │   ├── CounterEventHandler.kt\n│   │   │   ├── CounterViewModel.kt\n│   │   │   └── CounterFragment.kt\n│   │   ├── scorekeeper/\n│   │   │   ├── ScorekeeperEventHandler.kt\n│   │   │   ├── ScorekeeperViewModel.kt\n│   │   │   └── ScorekeeperFragment.kt\n│   │   ├── bgg/\n│   │   │   ├── BggEventHandler.kt\n│   │   │   ├── BggViewModel.kt\n│   │   │   └── BggFragment.kt\n│   │   └── kitchensink/\n│   │       ├── KitchenSinkEventHandler.kt\n│   │       ├── KitchenSinkViewModel.kt\n│   │       └── KitchenSinkFragment.kt\n│   ├── MainApplication.kt\n│   └── MainActivity.kt\n├── src/iosMain/kotlin/\n│   └── ui/\n│       ├── counter/\n│       │   ├── CounterEventHandler.kt\n│       │   └── CounterViewModel.kt\n│       ├── scorekeeper/\n│       │   ├── ScorekeeperEventHandler.kt\n│       │   └── ScorekeeperViewModel.kt\n│       ├── bgg/\n│       │   ├── BggEventHandler.kt\n│       │   └── BggViewModel.kt\n│       └── kitchensink/\n│           ├── KitchenSinkEventHandler.kt\n│           └── KitchenSinkViewModel.kt\n└── src/jsMain/kotlin/\n    ├── ui/\n    │   ├── counter/\n    │   │   ├── CounterEventHandler.kt\n    │   │   ├── CounterViewModel.kt\n    │   │   └── CounterComponent.kt\n    │   ├── scorekeeper/\n    │   │   ├── ScorekeeperEventHandler.kt\n    │   │   ├── ScorekeeperViewModel.kt\n    │   │   └── ScorekeeperComponent.kt\n    │   ├── bgg/\n    │   │   ├── BggEventHandler.kt\n    │   │   ├── BggViewModel.kt\n    │   │   └── BggComponent.kt\n    │   └── kitchensink/\n    │       ├── KitchenSinkEventHandler.kt\n    │       ├── KitchenSinkViewModel.kt\n    │       └── KitchenSinkComponent.kt\n    └── main.kt\n<\/code><\/pre>\n"
        }]
      },
      "modules": {
        "ownKey": "modules",
        "childrenPages": {
          "ballast-core": {
            "ownKey": "ballast-core",
            "ownPages": [{
              "reference": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-core",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-core"
              },
              "next": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-saved-state",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state"
              },
              "previous": {
                "path": "wiki",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "modules",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules"
              },
              "description": "",
              "title": "Ballast Core",
              "content": "<h1 id=\"ballast-core\"><a href=\"#ballast-core\" id=\"ballast-core\" class=\"anchor\"><\/a>Ballast Core<\/h1>\n<h2 id=\"overview\"><a href=\"#overview\" id=\"overview\" class=\"anchor\"><\/a>Overview<\/h2>\n<p>The Ballast Core module provides all the core capabilities of the entire Ballast MVI framework. The Core framework is\nrobust and opinionated, but also provides many ways to extend the functionality through Interceptors without impacting\nthe core MVI model. Any additional functionality outside of Core will typically be implemented as an Interceptor and\nprovided to the <code>BallastViewModelConfiguration<\/code>.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<h3 id=\"viewmodels\"><a href=\"#viewmodels\" id=\"viewmodels\" class=\"anchor\"><\/a>ViewModels<\/h3>\n<p>The Core module provides several ViewModel base classes, so Ballast can integrate natively with a variety of platforms.<\/p>\n<ul>\n<li><code>AndroidViewModel<\/code>: A subclass of <code>androidx.lifecycle.ViewModel<\/code><\/li>\n<li><code>IosViewModel<\/code>: A custom ViewModel that can be integrated with Combine Publishers for SwiftUI<\/li>\n<li><code>BasicViewModel<\/code>: A generic ViewModel for Kotlin targets that don't have their own platform-specific ViewModel, or for\nanywhere you want to manually control the lifecycle of the ViewModel. <code>BasicViewModel<\/code>'s lifecycle is controlled by a\n<code>coroutineScope<\/code> provided to it upon creation. When the scope gets cancelled, the ViewModel gets closed and can not be\nused again.<\/li>\n<\/ul>\n<h3 id=\"interceptors\"><a href=\"#interceptors\" id=\"interceptors\" class=\"anchor\"><\/a>Interceptors<\/h3>\n<p>The Core module comes with only one Interceptor,<\/p>\n<ul>\n<li><code>LoggingInterceptor<\/code>: It will print all Ballast activity to the logger provided in the <code>BallastViewModelConfiguration<\/code>.\nThe information logged by this interceptor may be quite verbose, but it can be really handy for quickly inspecting\nthe data in your ViewModel and what happened in what order.<\/li>\n<\/ul>\n<p>The <code>LoggingInterceptor<\/code> writes to a logger installed into the <code>BallastViewModelConfiguration<\/code>, which may be used by\nInputHandlers or other Ballast features as well.<\/p>\n<p>Ballast offers several logger implementations out-of-the-box:<\/p>\n<ul>\n<li><code>NoOpLogger<\/code>: The default implementation, it simply drops all messages and exceptions so nothing gets logged\naccidentally. It's recommended to use this in production builds, as well, and using <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase\">Ballast Firebase<\/a> to control\nwhat actually gets logged in production.<\/li>\n<li><code>PrintlnLogger<\/code>: Useful for quick-and-dirty logging on all platforms. It just writes log messages to stdout through\nprintln.<\/li>\n<li><code>AndroidBallastLogger<\/code>: Only available on Android, writes logs to the default LogCat at the appropriate levels.<\/li>\n<\/ul>\n<article class=\"message is-danger\">\n\n  <div class=\"message-body\">\n  <p>Be sure to only include <code>LoggingInterceptor()<\/code> and the logger in debug builds, as logging in production may cause\nperformance degradation and risks leaking sensitive info through to the application logs. It should not be used to\ncreate a paper-trail of activity in your app, you should use something like <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase\">Ballast Firebase<\/a> to more selectively\ncreate the paper-trail.<\/p>\n  <\/div>\n<\/article>\n<pre><code class=\"language-kotlin\">class ExampleViewModel(coroutineScope: CoroutineScope) : BasicViewModel&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;(\n  coroutineScope = coroutineScope,\n  config = BallastViewModelConfiguration.Builder()\n    .apply {\n      if(DEBUG) { // some build-time constant\n        logger = PrintlnLogger()\n        this += LoggingInterceptor()\n      }\n    }\n    .forViewModel(\n      initialState = ExampleContract.State(),\n      inputHandler = ExampleInputHandler(),\n      name = &quot;Example&quot;,\n    ),\n  eventHandler = ExampleEventHandler(),\n)\n<\/code><\/pre>\n<h3 id=\"input-strategies\"><a href=\"#input-strategies\" id=\"input-strategies\" class=\"anchor\"><\/a>Input Strategies<\/h3>\n<p>Ballast offers 3 different Input Strategies out-of-the-box, which each adapt Ballast's core functionality for different\napplications:<\/p>\n<ul>\n<li><code>LifoInputStrategy<\/code>: A last-in-first-out strategy for handling Inputs, and the default strategy if none is provided.\nOnly 1 Input will be processed at a time, and if a new Input is received while one is still working, the running Input\nwill be cancelled to immediately accept the new one. Corresponds to <code>Flow.collectLatest { }<\/code>, best for UI ViewModels.<\/li>\n<li><code>FifoInputStrategy<\/code>: A first-in-first-out strategy for handling Inputs. Inputs will be processed in the same order\nthey were sent and only ever one-at-a-time, but instead of cancelling running Inputs, new ones are queued and will be\nconsumed later when the queue is free. Corresponds to the normal <code>Flow.collect { }<\/code>, best for non-UI ViewModels.<\/li>\n<li><code>ParallelInputStrategy<\/code>: For specific edge-cases where neither of the above strategies works. Inputs are all handled\nconcurrently so you don't have to worry about blocking the queue or having Inputs cancelled. However, it places\nadditional restrictions on State reads/changes to prevent usage that might lead to race conditions.<\/li>\n<\/ul>\n<p>InputStrategies are responsible for creating the Channel used to buffer incoming Inputs, consuming the Inputs from that\nchannel, and providing a &quot;Guardian&quot; to ensure the Inputs are handled properly according the needs of that particular\nstrategy. The <code>DefaultGuardian<\/code> is a good starting place if you need to create your own <code>InputStrategy<\/code> to\nmaintain the same level of safety as the core strategies listed above.<\/p>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>Pro Tip: The text descriptions of these InputStrategies can be a bit confusing, but seeing them play out in real-time\nshould make it obvious how they work. Playing with the <a href=\"https://copper-leaf.github.io/ballast/wiki/examples/kitchensink\">Kitchen Sink<\/a> with the <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Debugger<\/a> gives you a simple way\nof experiencing these behaviors to get an intuition for when to use each one.<\/p>\n  <\/div>\n<\/article>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:ballast-core:2.1.0&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:ballast-core:2.1.0&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "ballast-saved-state": {
            "ownKey": "ballast-saved-state",
            "ownPages": [{
              "reference": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-saved-state",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state"
              },
              "next": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-repository",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository"
              },
              "previous": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-core",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-core"
              },
              "description": "",
              "title": "Ballast Saved State",
              "content": "<h1 id=\"ballast-saved-state\"><a href=\"#ballast-saved-state\" id=\"ballast-saved-state\" class=\"anchor\"><\/a>Ballast Saved State<\/h1>\n<h2 id=\"overview\"><a href=\"#overview\" id=\"overview\" class=\"anchor\"><\/a>Overview<\/h2>\n<p>Ballast ViewModels are held entirely in memory, but there are lots of cases where the ViewModel state needs to be saved\nin one session and restored in another. The traditional way to do this is to put all that saving/loading logic within\nthe InputHandler itself, but this can become messy and error-prone.<\/p>\n<p>The Saved State module implements the same kind of save/restore state functionality as an Interceptor. Using an\nInterceptor ensures that all changes to the State are persisted, and ensures that the ViewModel does nothing else while\nthe State is being loaded.<\/p>\n<p>Ballast Saved State offers a standard API to let you save the State to any persistent store you wish, but also offers\nout-of-the-box integration with <code>SavedStateHandle<\/code>.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>Start by creating a <code>SavedStateAdapter<\/code> for your ViewModel. This adapter includes functions to <code>save()<\/code> and <code>restore()<\/code>\nthe state, which will get called at the appropriate times.<\/p>\n<p><code>restore()<\/code> will be called initially when the <code>ViewModelStarted<\/code> is sent, and requires that no other Inputs get sent\nuntil after the State has been restored. If you need to do some additional initialization after the State has been\nloaded, you can override <code>onRestoreComplete()<\/code> to send an Input back to the VM once the State has been restored.<\/p>\n<p>The <code>save()<\/code> function will be called anytime the State gets updated. You can use the <code>saveDiff()<\/code> function to save\nindividual properties of the State only when they've changed, to reduce unnecessary writes.<\/p>\n<pre><code class=\"language-kotlin\">class ExampleSavedStateAdapter(\n    private val database: ExampleDatabase,\n) : SavedStateAdapter&lt;\n    ExampleContract.Inputs,\n    ExampleContract.Events,\n    ExampleContract.State&gt; {\n\n    override suspend fun SaveStateScope&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;.save() {\n        \n        saveDiff({ values }) { values -&gt;\n            database.saveValues(values)\n        }\n    }\n\n    override suspend fun RestoreStateScope&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;.restore(): ExampleContract.State {\n        return ExampleContract.State(\n            values = database.selectValues(values)\n        )\n    }\n}\n<\/code><\/pre>\n<p>Then, set up your ViewModel with the <code>BallastSavedStateInterceptor<\/code> added, which needs that Adapter we just created<\/p>\n<pre><code class=\"language-kotlin\">class ExampleViewModel(\n    coroutineScope: CoroutineScope,\n    database: ExampleDatabase,\n) : BasicViewModel&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;(\n    coroutineScope = coroutineScope,\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            this += BallastSavedStateInterceptor(\n                ExampleSavedStateAdapter(database)\n            )\n        }\n        .forViewModel(\n            initialState = ExampleContract.State(),\n            inputHandler = ExampleInputHandler(),\n            name = &quot;Example&quot;,\n        ),\n)\n<\/code><\/pre>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:ballast-saved-state:2.1.0&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:ballast-saved-state:2.1.0&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "ballast-debugger": {
            "ownKey": "ballast-debugger",
            "ownPages": [{
              "reference": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-debugger",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger"
              },
              "next": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-intellij-plugin",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-intellij-plugin"
              },
              "previous": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-firebase",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase"
              },
              "description": "",
              "title": "Ballast Debugger",
              "content": "<h1 id=\"ballast-debugger\"><a href=\"#ballast-debugger\" id=\"ballast-debugger\" class=\"anchor\"><\/a>Ballast Debugger<\/h1>\n<h2 id=\"overview\"><a href=\"#overview\" id=\"overview\" class=\"anchor\"><\/a>Overview<\/h2>\n<p>Ballast Debugger is a tool for inspecting the status of all components in your Ballast ViewModels in a IntelliJ plugin.\nIt supports features one would expect from an MVI graphical debugger:<\/p>\n<ul>\n<li>Inspecting the status and data within all ViewModel features in real-time<\/li>\n<li>Time-travel debugging<\/li>\n<li>Resending Inputs for re-processing<\/li>\n<\/ul>\n<p>The Ballast Debugger must first be installed as a plugin in IntelliJ Idea (Community or Ultimate) then add the\n<a href=\"#Installation\"><code>ballast-debugger<\/code><\/a> dependency to your project and installed into your ViewModels as an Interceptor.\nThis page documents how to set up the debugger library in your application, while the\n<a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-intellij-plugin\">Ballast Intellij Plugin<\/a> page demonstrates usage of the debugger UI, as well as the other features of the Intellij\nplugin.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>You will need to create a <code>BallastDebuggerClientConnection<\/code> with your choice of <a href=\"https://ktor.io/docs/http-client-engines.html\">Ktor client engine<\/a> and connect it\non an application-wide CoroutineScope. This will start a Websocket connection to the IntelliJ plugin's server over\nlocalhost on port <code>9684<\/code> (by default, this can be changed). The connection will automatically retry the connection until\nit succeeds, and reconnect if the connection is terminated. Finally, add the<code>BallastDebuggerInterceptor<\/code> which will send\nall its data through the websocket and be captured and displayed on the plugin's UI.<\/p>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>The same connection should be shared among all ViewModels, to optimize the system resource usage and make it easier to\nexplore in the Debugger UI.<\/p>\n  <\/div>\n<\/article>\n<article class=\"message is-danger\">\n\n  <div class=\"message-body\">\n  <p>As the debugger will drain system resources and potentially leak sensitive information, you must <strong>make sure<\/strong> the\ndebugger is not running in production. Configure your app to only start the connection and install the interceptor in\ndebug builds, or better yet, only include the debugger dependency in debug builds, so you know it could never be running\naccidentally.<\/p>\n  <\/div>\n<\/article>\n<pre><code class=\"language-kotlin\">val debuggerConnection by lazy {\n    val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n    BallastDebuggerClientConnection(\n        CIO,\n        applicationScope, \n        host = &quot;127.0.0.1&quot;, // 10.0.2.2 on Android\n    ) { \n        // CIO Ktor client engine configuration\n    }\n    .also { it.connect() }\n}\n\nclass ExampleViewModel(coroutineScope: CoroutineScope) : BasicViewModel&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;(\n    coroutineScope = coroutineScope, \n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            if(DEBUG) { // some build-time constant\n                this += BallastDebuggerInterceptor(debuggerConnection)\n            }\n        }\n        .forViewModel(\n            initialState = ExampleContract.State(),\n            inputHandler = ExampleInputHandler(),\n            name = &quot;Example&quot;,\n        ),\n    eventHandler = ExampleEventHandler(),\n)\n<\/code><\/pre>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:ballast-debugger:2.1.0&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:ballast-debugger:2.1.0&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "ballast-test": {
            "ownKey": "ballast-test",
            "ownPages": [{
              "reference": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-test",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-test"
              },
              "next": {
                "path": "wiki",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "examples",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/examples"
              },
              "previous": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-intellij-plugin",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-intellij-plugin"
              },
              "description": "",
              "title": "Ballast Test",
              "content": "<h1 id=\"ballast-test\"><a href=\"#ballast-test\" id=\"ballast-test\" class=\"anchor\"><\/a>Ballast Test<\/h1>\n<h2 id=\"overview\"><a href=\"#overview\" id=\"overview\" class=\"anchor\"><\/a>Overview<\/h2>\n<p>Ballast Test gives you a DSL you can include in any Kotlin testing framework to setup sequences of inputs and assert the\nresults of their processing.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>After <a href=\"#Installation\">including the dependency<\/a> into your test sourceSet, you can run <code>viewModelTest()<\/code>, which gives you\na DSL for setting up specific scenarios and asserting what happened during the execution of those scenarios.\n<code>viewModelTest()<\/code> is a suspending function, so it will need to be run within <code>runBlocking<\/code> in your tests.<\/p>\n<p>You do not need to provide a ViewModel implementation for these tests. A feature of Ballast is that the chosen ViewModel\nbase class is just a wrapper around the actual processor, and the test framework defines its own ViewModel class to run\nthe scenarios in. Instead, you just need to provide the other components you would normally pass to your ViewModel\nconfiguration, and then proceed setting your testing suite.<\/p>\n<p><code>viewModelTest()<\/code> defines an entire test suite for a single Ballast ViewModel, which contains many scenarios with\n<code>scenario(&quot;human-readbale scenario description&quot;)<\/code>. Most properties can be configured within the <code>viewModelTest { }<\/code>\nblock which will get applied to all scenarios, but each <code>scenario { }<\/code> can set their own values, which will override\nthose set for the suite.<\/p>\n<p>In each <code>scenario { }<\/code> block, <code>running { }<\/code> is the scenario script that will be run. Inputs are sent for processing\nusing the unary <code>+<\/code> operator, which will either send the Input and wait for it to be completed, or unary <code>-<\/code> which will\nsend the Input and immediately continue the script without waiting for it to complete. You'd typically want to use <code>+<\/code>\nunless you are explicitly wanting to test the cancellation behavior or something else that relies upon multiple Inputs\nbeing sent before the first has finished processing.<\/p>\n<p><code>resultsIn { }<\/code> will be called after the scenario has run to completion (or timed out), and will give a <code>TestResults<\/code>\nwhich contains all the values and their statues that were seen during the test scenario. You can use your favorite\nassertion library to make any assertions on any results within that object.<\/p>\n<pre><code class=\"language-kotlin\">@Test\nfun testExampleViewModel() = runBlocking&lt;Unit&gt; {\n    viewModelTest(\n        inputHandler = ExampleInputHandler(),\n        eventHandler = ExampleEventHandler(),\n        filter = null,\n    ) {\n        defaultInitialState { State() }\n        \n        scenario(&quot;update string value only&quot;) {\n            running {\n                +Inputs.UpdateStringValue(&quot;one&quot;)\n            }\n            resultsIn {\n                assertEquals(&quot;one&quot;, latestState.stringValue)\n                assertEquals(0, latestState.intValue)\n            }\n        }\n\n        scenario(&quot;increment int value only&quot;) {\n            running {\n                +Inputs.Increment\n                +Inputs.Increment\n            }\n            resultsIn {\n                assertEquals(2, latestState.intValue)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    testImplementation(&quot;io.github.copper-leaf:ballast-test:2.1.0&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonTest by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:ballast-test:2.1.0&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "ballast-firebase": {
            "ownKey": "ballast-firebase",
            "ownPages": [{
              "reference": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-firebase",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase"
              },
              "next": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-debugger",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger"
              },
              "previous": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-repository",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository"
              },
              "description": "",
              "title": "Ballast Firebase",
              "content": "<h1 id=\"ballast-firebase\"><a href=\"#ballast-firebase\" id=\"ballast-firebase\" class=\"anchor\"><\/a>Ballast Firebase<\/h1>\n<h2 id=\"overview\"><a href=\"#overview\" id=\"overview\" class=\"anchor\"><\/a>Overview<\/h2>\n<p>Ballast's Firebase modules offer an easy, declarative way to send data automatically to Firebase on Android. Analytics\nand Crashlytics are both supported, each with different modules, so you can pick and choose the features you need.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<h3 id=\"crashlytics\"><a href=\"#crashlytics\" id=\"crashlytics\" class=\"anchor\"><\/a>Crashlytics<\/h3>\n<p>Ballast's Crashlytics integration provides automatic tracing of your Inputs and gives you Logs and Keys attached to your\ncrash reports to aid in identifying and getting to the root cause of your application issues. Crashlytics should be\nintegrated in your app <a href=\"https://firebase.google.com/docs/crashlytics/get-started?platform=android\">as normal<\/a>, and then\nyou need to add the <a href=\"#Installation\"><code>ballast-crashlytics<\/code><\/a> dependency, and add the Interceptor to your ViewModel\nconfiguration. Note that the below example uses <code>AndroidViewModel<\/code>, but the <code>FirebaseCrashlyticsInterceptor<\/code> will work\njust the same with any other Ballast ViewModel type (Repositories, BasicViewModel, etc.).<\/p>\n<pre><code class=\"language-kotlin\">@HiltViewModel\nclass ExampleViewModel\n@Inject\nconstructor() : AndroidViewModel&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;(\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            this += FirebaseCrashlyticsInterceptor(Firebase.crashlytics)\n        }\n        .forViewModel(\n            initialState = ExampleContract.State(),\n            inputHandler = ExampleInputHandler(),\n            name = &quot;Example&quot;,\n        )\n)\n<\/code><\/pre>\n<p>Once installed, the Firebase Crashlytics integration will automatically start logging all Inputs to the\n<a href=\"https://firebase.google.com/docs/crashlytics/customize-crash-reports?platform=android#add-logs\">Firebase Crashlytics Logger<\/a>.<\/p>\n<p>However, it's likely that you don't actually want all Inputs sent to Firebase, especially for things like updating text,\nbecause they will spam the logs and hide the actual important steps the user had taken which led up to the error.\nAlternatively, you will probably have some inputs that contain sensitive information (passwords, API keys, PII, etc.)\nthat also should not be set to Firebase. By annotating any Input with <code>FirebaseCrashlyticsIgnore<\/code>, it will not be sent\nin the crash logs. Each Input will be logged using its <code>.toString()<\/code> value, so be sure to override <code>.toString()<\/code> for any\ninputs you do want tracked to remove any sensitive info from them.<\/p>\n<article class=\"message is-warning\">\n\n  <div class=\"message-body\">\n  <p>Add <code>@FirebaseCrashlyticsIgnore<\/code> to Inputs you do not want to sent to Firebase, to protect sensitive information.<\/p>\n  <\/div>\n<\/article>\n<p>In addition to logs, the <code>FirebaseCrashlyticsInterceptor<\/code> will also record any exceptions that are thrown but do not\ncrash the app as a <a href=\"https://firebase.google.com/docs/crashlytics/customize-crash-reports?platform=android#log-excepts\">non-fatal exception<\/a><\/p>\n<h3 id=\"analytics\"><a href=\"#analytics\" id=\"analytics\" class=\"anchor\"><\/a>Analytics<\/h3>\n<p>Ballast's Firebase Analytics integration provides automatic tracking of your Inputs to the Firebase Analytics dashboard.\nFirebase Analytics should be integrated in your app <a href=\"https://firebase.google.com/docs/analytics/get-started?platform=android\">as normal<\/a>, and then you need to add the\n<a href=\"#Installation\"><code>ballast-firebase-analytics<\/code><\/a> dependency and add the Interceptor to your ViewModel configuration. Note\nthat the below example uses <code>AndroidViewModel<\/code>, but the <code>FirebaseAnalyticsInterceptor<\/code> will work just the same with any\nother Ballast ViewModel type (Repositories, BasicViewModel, etc.).<\/p>\n<pre><code class=\"language-kotlin\">@HiltViewModel\nclass ExampleViewModel\n@Inject\nconstructor() : AndroidViewModel&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;(\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            this += FirebaseAnalyticsInterceptor(Firebase.analytics)\n        }\n        .forViewModel(\n            initialState = ExampleContract.State(),\n            inputHandler = ExampleInputHandler(),\n            name = &quot;Example&quot;,\n        )\n)\n<\/code><\/pre>\n<p>While Crashlytics takes an opt-out approach to logging Inputs, Analytics is entirely opt-in. Most Inputs in your app\nprobably aren't necessary to track, what you're mostly interested in is conversions. The <code>FirebaseAnalyticsInterceptor<\/code>\nwill only track Inputs that are annotated with <code>FirebaseAnalyticsTrackInput<\/code>, and ignore the rest. Each Input will be\nlogged using its <code>.toString()<\/code> value, so be sure to override <code>.toString()<\/code> for any inputs you want tracked to remove any\nsensitive info from them.<\/p>\n<article class=\"message is-warning\">\n\n  <div class=\"message-body\">\n  <p>Make sure any inputs annotated with <code>@FirebaseAnalyticsTrackInput<\/code> do not leak any senesitive information through\n<code>.toString()<\/code>.<\/p>\n  <\/div>\n<\/article>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:ballast-crashlytics:2.1.0&quot;)\n    implementation(&quot;io.github.copper-leaf:ballast-firebase-analytics:2.1.0&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:ballast-crashlytics:2.1.0&quot;)\n                implementation(&quot;io.github.copper-leaf:ballast-firebase-analytics:2.1.0&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "ballast-repository": {
            "ownKey": "ballast-repository",
            "ownPages": [{
              "reference": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-repository",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository"
              },
              "next": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-firebase",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase"
              },
              "previous": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-saved-state",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state"
              },
              "description": "",
              "title": "Ballast Repository",
              "content": "<h1 id=\"ballast-repository\"><a href=\"#ballast-repository\" id=\"ballast-repository\" class=\"anchor\"><\/a>Ballast Repository<\/h1>\n<h2 id=\"overview\"><a href=\"#overview\" id=\"overview\" class=\"anchor\"><\/a>Overview<\/h2>\n<p>MVI has been known for a while as a great option for managing UI state, but most applications will also need to manage\nsome state that lives longer than a single screen. This would be things like account management, or caching of expensive\ncomputations or API calls, and MVI can actually be a great fit for this Repository Layer, too. The <a href=\"https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff649690(v=pandp.10)?redirectedfrom=MSDN\">Repository Layer<\/a>\nhas a lifetime that is longer than any single screen, and acts as a liaison between your UI code (the typical MVI area)\nand the domain objects that make the UI work.<\/p>\n<p>On Android, it's recommended to have a <a href=\"https://developer.android.com/jetpack/guide#data-layer\">Data Layer<\/a>, but exactly how to build it is not well known, and there really\naren't any recommendations from Google, either. <a href=\"https://github.com/dropbox/Store\">Dropbox Store<\/a> attempted to step in and create a library to\nimplement this Data or Repository layer, but in practice it works more like a persistent cache than a true solution for\napp-wide State management.<\/p>\n<p>Ballast Repository aims to fill that gap, and provide an opinionated way to manage the data in your application layer,\nusing the same MVI model you're used to with your UI code. One huge benefit of using Ballast as your repository layer\nvs other solutions, is that you can approach both UI and non-UI development with the same mindset; you don't have to\n&quot;context switch&quot; when moving between layers!<\/p>\n<p>Ballast Repository is built around 3 core concepts: the MVI model as implemented with a special <code>BallastRepository<\/code>\nViewModel, the <code>Cached&lt;T&gt;<\/code> interface to hold and update data within the Repository, and the <code>EventBus<\/code> to facilitate\ncommunication between Repository instances throughout the entire layer.<\/p>\n<h2 id=\"example-use-case\"><a href=\"#example-use-case\" id=\"example-use-case\" class=\"anchor\"><\/a>Example Use-Case<\/h2>\n<p>Before diving into the usage of the Repository module, it may be helpful to get a basic intuition for when you might\nneed it, and how this layer of your application is intended to work. Consider the following situation:<\/p>\n<p>You have an app where users can log on and view how much they've used your service, and how much it costs them. The\nusers may have multiple linked accounts and switch between the accounts freely. Viewing their usage is tied to the\nindividual account, but billing is aggregated among all accounts to simplify paying the bill.<\/p>\n<p>We want to minimize the number of API calls for a snappy user-experience, so we cache every API response. Whenever the\nuser changes the current account, we want to refresh their usage data, but not the billing info, since we want to show\nthe new usage data for the new account, but the billing data does not need to be changed.<\/p>\n<p>In this model, using a <a href=\"#BallastRepository\">BallastRepository<\/a>, we would hold the user account info in an\n<code>AccountRepository<\/code>, the usage data in <code>UsageRepository<\/code>, and billing info in <code>BillingRepository<\/code>. All the cached data\nis held within a <a href=\"#Cached\"><code>Cached&lt;T&gt;<\/code><\/a> property of each Repository's State. Changing accounts involves sending an Input\nto <code>AccountRepository<\/code>, which then makes its own changes and then sends the relevant Input through the\n<a href=\"#EventBus\"><code>EventBus<\/code><\/a> to the <code>BillingRepository<\/code>. The UI layer does not need to know any specifics of what's going on\nin the Repository layer, as it just passively observes the <code>Cached<\/code> properties. Furthermore, it also does not need to\nknow anything about the specific organization of data in it, when changing one property needs to clear the cache of\nanother, etc. You can easily wire up any screen to change the account or fetch the usage/billing info, trust that it\nwill be fetched only once if needed or else returned from the cache, and know that the relevant UI will be updated\nautomatically whenever the repository finished updating its cached without having to do any specific UI handling for\nthat.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<h3 id=\"ballastrepository\"><a href=\"#ballastrepository\" id=\"ballastrepository\" class=\"anchor\"><\/a>BallastRepository<\/h3>\n<p><code>BallastRepository<\/code> is a special <code>BallastViewModel<\/code> implementation that is intended to be used as the &quot;ViewModel&quot; of\nyour Repository layer. Unlike UI ViewModels, the Repositories do not have <code>EventHandlers<\/code>, as Events sent from the\nRepository InputHandler are sent to the EventBus instead (which is simply a SharedFlow). It also uses the\n<code>FifoInputStrategy<\/code> to ensure that all Inputs are handled, rather than being dropped or cancelled, though they're still\nprocessed one-at-a-time.<\/p>\n<p>Repositories need a <code>CoroutineScope<\/code> to control their lifetime (commonly a single, glogal Application CoroutineScope),\nand the <code>EventBus<\/code> instance, which should be shared among all Repositories. There also exists a\n<code>AndroidBallastRepository<\/code> which implements the same semantics, but is an instance of <code>androidx.lifecycle.ViewModel<\/code> and\nso can be scoped to a Navigation sub-graph.<\/p>\n<pre><code class=\"language-kotlin\">class ExampleRepositoryImpl(\n    coroutineScope: CoroutineScope,\n    eventBus: EventBus,\n) : BallastRepository&lt;\n        ExampleRepositoryContract.Inputs,\n        ExampleRepositoryContract.State&gt;(\n    coroutineScope = coroutineScope,\n    eventBus = eventBus,\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            initialState = ExampleRepositoryContract.State()\n            inputHandler = ExampleRepositoryInputHandler()\n            name = &quot;Example Repository&quot;\n        }\n)\n<\/code><\/pre>\n<p>The <code>Contract<\/code> for a Repository can be anything you need it to be, but a common implementation based around Ballast's\nown <code>Cached&lt;T&gt;<\/code> interface looks like the example below. You can add as many cached properties to the same Repository as\nneeded, but they should typically be related by domain.<\/p>\n<pre><code class=\"language-kotlin\">object ExampleRepositoryContract {\n    data class State(\n        val initialized: Boolean = false,\n        \n        val examplePropertyInitialized: Boolean = false,\n        val exampleProperty: Cached&lt;ExampleValue&gt; = Cached.NotLoaded(),\n    )\n\n    sealed class Inputs {\n        object ClearCaches : Inputs()\n        object Initialize : Inputs()\n        object RefreshAllCaches : Inputs()\n\n        data class RefreshExampleProperty(val forceRefresh: Boolean) : Inputs()\n        data class ExamplePropertyUpdated(val value: Cached&lt;ExampleValue&gt;) : Inputs()\n    }\n}\n<\/code><\/pre>\n<p>The corresponding InputHandler is also very much templated, using the <code>fetchWithCache()<\/code> function to determine when to\nupdate the cached value:<\/p>\n<pre><code class=\"language-kotlin\">class ExampleRepositoryInputHandler(\n    private val exampleApi: ExampleApi,\n) : InputHandler&lt;\n    ExampleRepositoryContract.Inputs,\n    Any,\n    ExampleRepositoryContract.State&gt; {\n\n    override suspend fun InputHandlerScope&lt;\n        ExampleRepositoryContract.Inputs,\n        Any,\n        ExampleRepositoryContract.State&gt;.handleInput(\n        input: ExampleRepositoryContract.Inputs\n    ) = when (input) {\n        is ExampleRepositoryContract.Inputs.ClearCaches -&gt; {\n            updateState { ExampleRepositoryContract.State() }\n        }\n        is ExampleRepositoryContract.Inputs.Initialize -&gt; {\n            val previousState = getCurrentState()\n\n            if (!previousState.initialized) {\n                updateState { it.copy(initialized = true) }\n                // start observing flows here\n                logger.debug(&quot;initializing&quot;)\n                observeFlows(\n                    key = &quot;Observe account changes&quot;,\n                    params.eventBus\n                        .observeInputsFromBus&lt;ExampleRepositoryContract.Inputs&gt;(),\n                )\n            } else {\n                logger.debug(&quot;already initialized&quot;)\n                noOp()\n            }\n        }\n\n        is ExampleRepositoryContract.Inputs.RefreshAllCaches -&gt; {\n            // refresh all the caches in this repository\n            val currentState = getCurrentState()\n            if (currentState.examplePropertyInitialized) {\n                postInput(ExampleRepositoryContract.Inputs.RefreshExampleProperty(true))\n            }\n\n            Unit\n        }\n        \n        is ExampleRepositoryContract.Inputs.RefreshExampleProperty -&gt; {\n            updateState { it.copy(examplePropertyInitialized = true) }\n            fetchWithCache(\n                input = input,\n                forceRefresh = input.forceRefresh,\n                getValue = { it.exampleProperty },\n                updateState = { ExampleRepositoryContract.Inputs.ExamplePropertyUpdated(it) },\n                doFetch = {\n                    exampleApi.fetchValue()\n                },\n            )\n        }\n        is ExampleRepositoryContract.Inputs.ExamplePropertyUpdated -&gt; {\n            updateState { it.copy(value = input.value) }\n        }\n    }\n}\n<\/code><\/pre>\n<p>The final piece of the puzzle is where things start to look a bit different from normal UI MVI usage. A Ballast\nRepository typically shouldn't be directly exposed to the UI, but instead hidden behind an interface so the UI layers\ndon't need to worry about sending the right Inputs and the right time to clear the caches, etc. Instead the UI just\nrequests data from the Repository interface as normal and receives the data it needs as a flow, while the Ballast\nRepository does all the work in the background to fetch or return cached data.<\/p>\n<pre><code class=\"language-kotlin\">public interface ExampleRepository { \n    fun getExampleValue(refreshCache: Boolean): Flow&lt;Cached&lt;ExampleValue&gt;&gt;\n}\n<\/code><\/pre>\n<p>The class that extends <code>BallastRepository<\/code> should then also implement the interface, and send the correct Inputs as the\nUI requests data. This makes the actual fetches of data lazy.<\/p>\n<pre><code class=\"language-kotlin\">class ExampleRepositoryImpl(\n    coroutineScope: CoroutineScope,\n    eventBus: EventBus,\n) : BallastRepository&lt;\n        ExampleRepositoryContract.Inputs,\n        ExampleRepositoryContract.State&gt;(\n    coroutineScope = coroutineScope,\n    eventBus = eventBus,\n    config = BallastViewModelConfiguration.Builder()\n        .apply {\n            initialState = ExampleRepositoryContract.State()\n            inputHandler = ExampleRepositoryInputHandler()\n            name = &quot;Example Repository&quot;\n        }\n), ExampleRepository {\n\n    override fun getExampleValue(refreshCache: Boolean): Flow&lt;Cached&lt;ExampleValue&gt;&gt; { \n        trySend(ExampleRepositoryContract.Inputs.Initialize)\n        trySend(ExampleRepositoryContract.Inputs.RefreshExampleProperty(refreshCache))\n        return observeStates()\n            .map { it.exampleProperty }\n    }\n    \n}\n<\/code><\/pre>\n<p>There is a lot of boilerplate to this method, and eventually there may be a generic Caching Repository to do all this\nfor you. But for now, it's best to just be explicit, so you can easily track what data is being changed and at what time\nwithin each Repository.<\/p>\n<h3 id=\"eventbus\"><a href=\"#eventbus\" id=\"eventbus\" class=\"anchor\"><\/a>EventBus<\/h3>\n<p>The <code>EventBus<\/code> class is basically just a wrapper around a <code>SharedFlow<\/code>. It should share the same instance among all\nRepositories, so that one Repository can post an event to the bus, and it will be delivered to another Repository.<\/p>\n<p>Each Repository should typically observe values of its own type from the EventBus, using\n<code>eventBus.observeInputsFromBus&lt;ExampleRepositoryContract.Inputs&gt;()<\/code>, but you're free to observe values of any type. An\nexample is using a generic &quot;ClearCache&quot; token sent to the bus, and all repositories can watch for that token and clear\nthemselves.<\/p>\n<p>Values can be sent from one Repository to another with the normal <code>InputHandlerScope.postEvent()<\/code>. You can post any\nnon-null value, as the <code>Events<\/code> type is <code>Any<\/code>.<\/p>\n<h3 id=\"cached\"><a href=\"#cached\" id=\"cached\" class=\"anchor\"><\/a>Cached<\/h3>\n<p><code>Cached<\/code> is a sealed class which holds the data in your Repository and notifies observers of all changes to that value\nas it is loaded. It can be one of 4 states: <code>NotLoaded<\/code>, <code>Fetching<\/code>, <code>Value<\/code>, or <code>FetchingFailed<\/code>.<\/p>\n<p>For values that need to be loaded once from some remote source or expensive computation, use <code>fetchWithCache()<\/code> within\nyour InputHandler in response to a <code>Refresh*<\/code> Inputs. That function takes care of determining when to fetch new values\nand capturing errors from the fetcher. But one particular feature of it is that when a hard refresh is requested, the\nstate will change the previously-cached value will be carried through those states until a new value finally returns,\nwhich can be used to show a progress indicator in the UI with the old values, rather than clearing the entire screen\nwhile loading. The <code>Cached&lt;T&gt;<\/code> value has a number of extension functions to help in displaying the right things in the\nUI according to the status of that cached value.<\/p>\n<p>When a UI ViewModel is observing a <code>Cached&lt;T&gt;<\/code> property from a Repository, you should think of it as if the UI ViewModel\nsimply observes a &quot;view&quot; of the repository. Technically, the cached values will be copied into the UI ViewModel, but\nthere shouldn't be any reason to change the value directly in the UI ViewModel. Instead, send those changes back to the\nRepository and wait for it to get changed there, at which point the updated value will flow back into the UI ViewModel.\nAlso, do not unwrap the Cached value in the UI ViewModel, continue to hold onto it as the wrapped <code>Cached&lt;T&gt;<\/code> value so\nthat the UI can use the Cached DSL to optimize its display of the inner value.<\/p>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:ballast-repository:2.1.0&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:ballast-repository:2.1.0&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "ballast-intellij-plugin": {
            "ownKey": "ballast-intellij-plugin",
            "ownPages": [{
              "reference": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-intellij-plugin",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-intellij-plugin"
              },
              "next": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-test",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-test"
              },
              "previous": {
                "path": "wiki/modules",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ballast-debugger",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger"
              },
              "description": "",
              "title": "Ballast Intellij Plugin",
              "content": "<h1 id=\"ballast-intellij-plugin\"><a href=\"#ballast-intellij-plugin\" id=\"ballast-intellij-plugin\" class=\"anchor\"><\/a>Ballast Intellij Plugin<\/h1>\n<h2 id=\"overview\"><a href=\"#overview\" id=\"overview\" class=\"anchor\"><\/a>Overview<\/h2>\n<p>Ballast has an official Intellij plugin which offers several useful tools for developing applications with Ballast:<\/p>\n<ul>\n<li>Real-time inspection of the status and data within all ViewModel features<\/li>\n<li>Time-travel debugging<\/li>\n<li>Templates for creating new Ballast components<\/li>\n<\/ul>\n<p>The plugin is still in its early days of development, but will be gaining more features and additional configuration\nsettings as time goes on. This page documents how to install and use all the features of the Intellij plugin, while the\n<a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a> page shows how to install the debugger into your application so it can connect to the plugin.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<h3 id=\"debugger\"><a href=\"#debugger\" id=\"debugger\" class=\"anchor\"><\/a>Debugger<\/h3>\n<p>The following video shows some example usage of the debugger<\/p>\n<p><video controls=\"controls\" width=\"800\" height=\"600\" name=\"Ballast Debugger Example\">\n<source src=\"https://copper-leaf.github.io/ballast/assets/media/debugger_example_720p.mp4\">\n<\/video><\/p>\n<p><em><a href=\"https://copper-leaf.github.io/ballast/assets/media/debugger_example_720p.mp4\">Video direct download link<\/a><\/em><\/p>\n<h4 id=\"connecting-to-the-debugger\"><a href=\"#connecting-to-the-debugger\" id=\"connecting-to-the-debugger\" class=\"anchor\"><\/a>Connecting to the debugger<\/h4>\n<p>Once installed, a new &quot;Ballast Debugger&quot; tool window will be added to the bottom-right of the IDE, which can be opened\nto start the debugger. The debugger communicates via websockets to client applications that have the\n<a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a> interceptor installed. The debugger communicates over localhost on port <code>9684<\/code>, which can be\nchanged from within the Preferences dialog. For desktop and other applications not running in a virtual machine, you can\nconnect using the normal loopback interface at <code>127.0.0.1<\/code>. Android emulators must use the emulated device's alias\nto the host computer's loopback at <code>10.0.2.2<\/code>.<\/p>\n<p>The debugger's websocket server will only be active for as long as the tool window is open, but the client interceptors\nwill continually attempt to reconnect to the server if the connection is terminated (such as by closing the tool\nwindow). The clients attempt a reconnection every few seconds, and any time it needs to send an event to the server. If\nthe tool window is open, simply by interacting with your app it will reconnect to the debugger UI in the Intellij\nplugin, there is no need to restart your application or force a reconnection attempt.<\/p>\n<p>Once connected, the client connection will send all events from its connected ViewModels through the websocket, and be\ninterpreted by the server and displayed in real-time. The connection will also send a heartbeat every few seconds, so\nyou can see whether the connection is still alive, even if nothing is happening in your ViewModels.<\/p>\n<h4 id=\"using-the-debugger\"><a href=\"#using-the-debugger\" id=\"using-the-debugger\" class=\"anchor\"><\/a>Using the Debugger<\/h4>\n<p>Once connected, the connection will be assigned a UUID and added to the &quot;Connections&quot; column, with the most recent\nconnections at the top of the list. You can right-click the header to clear all connections from that column.<\/p>\n<p>By clicking a connection, it will open up a second column with all the ViewModels communicating through that connection.\nYou should typically have 1 connection per app launch, but multiple devices may be connected simultanously. You can\nright-click the connection to clear all the data from that connection, which is the same as right-clicking the header\nof the second column.<\/p>\n<p>Each ViewModel in the &quot;ViewModels&quot; column will highlight its icons when anything is being processed, and if more than\n1 side job or Input are processing concurrently, a badge will be shown with the number of items being processed. If the\nconnection was established after the ViewModel started running, you can right-click the ViewModel and select &quot;Refresh&quot;\nto request the client resend all the activity that may have been missed. Depending on how long the ViewModel has been\nrunning and how many Inputs were processed, this may take a few seconds to complete.<\/p>\n<p>Clicking a ViewModel will focus it and show a tabbed view of States, Inputs, Events, and SideJobs. Each of these shows\na list of each discrete instance that has been processed, and the status of that item. Newest items are always at the\ntop of the list. You can select any item to focus it and view more details about that item. Note that the text that\nshows is typically the result of calling <code>.toString()<\/code> on the object in the client, and so the actual representation\nmay vary between different platforms.<\/p>\n<h3 id=\"scaffolding\"><a href=\"#scaffolding\" id=\"scaffolding\" class=\"anchor\"><\/a>Scaffolding<\/h3>\n<p>You can quickly create files for new Ballast components from the file explorers &quot;Right-click &gt; New&quot; menu, using\nIntellij's <a href=\"https://www.jetbrains.com/help/idea/settings-file-and-code-templates.html\">File and Code Templates feature<\/a>. See the following clip for example usage in a Compose Desktop\napplication.<\/p>\n<p><video controls=\"controls\" width=\"800\" height=\"600\" name=\"Ballast Scaffolding Example\">\n<source src=\"https://copper-leaf.github.io/ballast/assets/media/scaffolding_example_720p.mp4\">\n<\/video><\/p>\n<p><em><a href=\"https://copper-leaf.github.io/ballast/assets/media/scaffolding_example_720p.mp4\">Video direct download link<\/a><\/em><\/p>\n<p>There are 3 options for creating new components, which themselves have several options for the components available to\ngenerate:<\/p>\n<ul>\n<li><strong>Ballast UI Component<\/strong>: Components used for normal UI ViewModels (excluding the ViewModel class itself)\n<ul>\n<li><em>Contract<\/em>: A simple Contract with <code>Initialize<\/code> and <code>GoBack<\/code> inputs which would be used by most screens<\/li>\n<li><em>InputHandler<\/em>: An InputHandler to process the sample Contract's Inputs<\/li>\n<li><em>EventHandler<\/em>: An empty EventHandler to process the sample Contract's Events<\/li>\n<li><em>SavedStateAdapter<\/em>: An adapter for the <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state\">SavedStateAdapter<\/a> module<\/li>\n<\/ul>\n<\/li>\n<li><strong>Ballast ViewModel<\/strong>: The ViewModel class for normal UI ViewModels\n<ul>\n<li><em>BasicViewModel<\/em>: An implementation which can be used on any arbitrary platform, including Kotlin targets that don't have their own platform-specific ViewModel<\/li>\n<li><em>AndroidViewModel<\/em>: The implementation typically used on Android targets, which extends <code>androidx.lifecycle.ViewModel<\/code><\/li>\n<li><em>IosViewModel<\/em>: The implementation required for iOS targets, which integrates with the Swift Combine framework<\/li>\n<\/ul>\n<\/li>\n<li><strong>Ballast Repository Component<\/strong>: The components and &quot;ViewModel&quot; class for <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Ballast Repositories<\/a>\n<ul>\n<li><em>Contract<\/em>: A simple Contract with <code>Cached<\/code> properties used by a <code>BallastRepository<\/code><\/li>\n<li><em>Repository<\/em>: The simple Repository interface that is exposed to UI ViewModels<\/li>\n<li><em>InputHandler<\/em>: An InputHandler to process the sample Contract's Inputs<\/li>\n<li><em>RepositoryImpl<\/em>: A Repository implementation which can be used on any arbitrary platform, which exposes the sample Repository interface<\/li>\n<li><em>AndroidRepositoryImpl<\/em>: A Repository implementation which extends <code>androidx.lifecycle.ViewModel<\/code>, which exposes the sample Repository interface<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<p>You can always generate just a single file at a time with the above-named templates, but there are some additional\noptions which may generate more than one template in a single action, for your convenience.<\/p>\n<p>You can also change the content generated from any template in <code>Preferences &gt; Editor &gt; File and Code Templates &gt; Other<\/code>,\nthough this is not recommended as future changes to the templates in the Intellij plugin will not be reflected\nautomatically in your edited version.<\/p>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<div id=\"intellij-plugin-button\"><\/div>\n<br>\n<p>The button above will take you to the plugin landing page, or you can search for &quot;Ballast&quot; in the plugin marketplace\nwithin IntelliJ-based IDEs. Note that the plugin's UI is built with <a href=\"https://plugins.jetbrains.com/plugin/18439-compose-for-ide-plugin-development-experimental-\">Compose for IDE Plugin Development<\/a>, which is\nstill very early and only available in the latest versions of IntelliJ IDEA. It should work in both Community and\nUltimate editions on IntelliJ IDEA, however, at this time, the latest stable version of Android Studio is not supported.<\/p>\n"
            }]
          }
        },
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "modules",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/modules"
          },
          "next": {
            "path": "wiki/modules",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "ballast-core",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/modules/ballast-core"
          },
          "previous": {
            "path": "wiki/platforms",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "compose-web",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/platforms/compose-web"
          },
          "description": "",
          "title": "Modules",
          "content": "<h1 id=\"modules\"><a href=\"#modules\" id=\"modules\" class=\"anchor\"><\/a>Modules<\/h1>\n<ul>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-core\">Ballast Core<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state\">Ballast Saved State<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Ballast Repository<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase\">Ballast Firebase<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-intellij-plugin\">Ballast Intellij Plugin<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-test\">Ballast Test<\/a><\/li>\n<\/ul>\n"
        }]
      },
      "platforms": {
        "ownKey": "platforms",
        "childrenPages": {
          "compose-desktop": {
            "ownKey": "compose-desktop",
            "ownPages": [{
              "reference": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "compose-desktop",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/compose-desktop"
              },
              "next": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "compose-web",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/compose-web"
              },
              "previous": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ios",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/ios"
              },
              "description": "",
              "title": "Compose Desktop (JVM)",
              "content": "<h1 id=\"compose-desktop-jvm\"><a href=\"#compose-desktop-jvm\" id=\"compose-desktop-jvm\" class=\"anchor\"><\/a>Compose Desktop (JVM)<\/h1>\n<p>There is no special support needed to use Ballast in <a href=\"https://www.jetbrains.com/lp/compose-mpp/\">Compose Desktop<\/a> or other <a href=\"https://kotlinlang.org/docs/jvm-get-started.html\">Kotlin/JVM<\/a> applications. You\nwill use the <code>BasicViewModel<\/code> as your ViewModel implementation, and connect it to a custom <code>CoroutineScope<\/code> to control\nits lifecycle.<\/p>\n<h2 id=\"example\"><a href=\"#example\" id=\"example\" class=\"anchor\"><\/a>Example<\/h2>\n<pre><code class=\"language-kotlin\">fun main() {\n    singleWindowApplication {\n        MaterialTheme {\n            val applicationCoroutineScope = rememberCoroutineScope()\n            val viewModel = remember(applicationCoroutineScope) { ExampleViewModel(applicationCoroutineScope) }\n            val uiState by viewModel.observeStates().collectAsState()\n            Content(uiState) {\n                viewModel.trySend(it)\n            }\n        }\n    }\n}\n\n@Composable\nfun ExampleContent(\n    uiState: ExampleContract.State = ExampleContract.State(),\n    postInput: (ExampleContract.Inputs) -&gt; Unit = {},\n) {\n    // ...\n}\n<\/code><\/pre>\n"
            }]
          },
          "android": {
            "ownKey": "android",
            "ownPages": [{
              "reference": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "android",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/android"
              },
              "next": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ios",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/ios"
              },
              "previous": {
                "path": "wiki",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "platforms",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms"
              },
              "description": "",
              "title": "Android",
              "content": "<h1 id=\"android\"><a href=\"#android\" id=\"android\" class=\"anchor\"><\/a>Android<\/h1>\n<p>There is no special support required to use Ballast in native Android applications. It works with both Compose and\ntraditional XML View-based screens, as well as Activity-, Fragment-, or pure-Compose-based screens/navigation.<\/p>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<h3 id=\"androidviewmodel\"><a href=\"#androidviewmodel\" id=\"androidviewmodel\" class=\"anchor\"><\/a>AndroidViewModel<\/h3>\n<p>Ballast offers <code>AndroidViewModel<\/code>, which is a subclass of <code>androidx.lifecycle.ViewModel<\/code> and uses the\n<code>viewModelScope<\/code> to control the ViewModel's lifecycle. Subclasses of <code>AndroidViewModel<\/code> can be scoped to Activities,\nFragments, or NavGraphs as usual, and also work with <a href=\"https://dagger.dev/hilt/view-model.html\">Hilt's <code>@AndroidViewModel<\/code> injection<\/a>. There is also a\n<code>AndroidBallastRepository<\/code> which extends <code>androidx.lifecycle.ViewModel<\/code> as the Android-specific analog of\n<code>BallastRepository<\/code> from the <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Ballast Repository<\/a> module.<\/p>\n<p>An <code>AndroidViewModel<\/code> intentionally does not have access to the Activity or Fragment it is typically associated with\nwhen created or during Hilt injection, as it lives longer than the associated Activity/Fragment. Thus, it is not\npossible to provide the <code>EventHandler<\/code> directly an instance of <code>AndroidViewModel<\/code> with Hilt. It will have to be attached\ndynamically with <code>vm.attachEventHandler()<\/code> after creation. In a View-based screen, this would be attached in a\nFragment's <code>onViewCreated()<\/code> callback or an Activity's <code>onStart()<\/code> or <code>onResume()<\/code> callbacks. In either case, the\nEventHandler itself will only be active during the <code>RESUMED<\/code> state, and collected <a href=\"https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(androidx.lifecycle.Lifecycle).repeatOnLifecycle(androidx.lifecycle.Lifecycle.State,kotlin.coroutines.SuspendFunction1)\">safely with <code>repeatOnLifecycle<\/code><\/a>.\nWithin Compose, you can call <code>vm.attachEventHandler()<\/code> within a <code>LaunchedEffect<\/code> to handle events on the coroutineScope\nof a particular Composable function.<\/p>\n<h3 id=\"other\"><a href=\"#other\" id=\"other\" class=\"anchor\"><\/a>Other<\/h3>\n<p>if you need to control its lifecycle with another <code>CoroutineScope<\/code> (such as when scoping the ViewModel to a Compose\nfunction), you can use the normal <code>BasicViewModel<\/code> as your ViewModel implementation. The <code>BasicViewModel<\/code> is unrelated to\n<code>androidx.lifecycle.ViewModel<\/code>, and thus it cannot be provided from any of the normal Android ViewModel mechanisms, but\ngives you more flexibility over the lifetime of the ViewModel.<\/p>\n<h2 id=\"examples\"><a href=\"#examples\" id=\"examples\" class=\"anchor\"><\/a>Examples<\/h2>\n<h3 id=\"xml-views\"><a href=\"#xml-views\" id=\"xml-views\" class=\"anchor\"><\/a>XML Views<\/h3>\n<pre><code class=\"language-kotlin\">@AndroidEntryPoint\nclass ExampleFragment : ComposeFragment() {\n\n    @Inject\n    lateinit var eventHandler: ExampleEventHandler.Factory\n\n    private val viewModel: ExampleViewModel by viewModels()\n    \n    private var binding: FragmentExampleBinding? = null\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return FragmentExampleBinding\n            .inflate(inflater, container, false)\n            .also { binding = it }\n            .root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        // events are sent back to the screen during the Fragment's Lifecycle RESUMED state\n        viewModel.attachEventHandlerOnLifecycle(\n            this,\n            eventHandler.create(this, findNavController()),\n        )\n        \n        // Collect the state on the Fragment's Lifecycle RESUMED state, updating the entire UI with each change\n        vm.observeStatesOnLifecycle(this) { state -&gt; \n            binding?.updateWithState(state) { viewModel.trySend(it) } \n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        binding = null\n    }\n\n    private fun FragmentExampleBinding.updateWithState(\n        state: ExampleContract.State,\n        postInput: (ExampleContract.Inputs) -&gt; Unit\n    ) {\n        tvCounter.text = &quot;${state.count}&quot;\n\n        btnDec.setOnClickListener { postInput(ExampleContract.Inputs.Decrement(1)) }\n        btnInc.setOnClickListener { postInput(ExampleContract.Inputs.Increment(1)) }\n    }\n}\n<\/code><\/pre>\n<h3 id=\"compose\"><a href=\"#compose\" id=\"compose\" class=\"anchor\"><\/a>Compose<\/h3>\n<pre><code class=\"language-kotlin\">@AndroidEntryPoint\nclass ExampleFragment : ComposeFragment() {\n\n    @Inject\n    lateinit var eventHandler: ExampleEventHandler.Factory\n\n    private val viewModel: ExampleViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return ComposeView(requireContext()).apply {\n            setContent {\n                MaterialTheme {\n                    val uiState by viewModel.observeStates().collectAsState()\n                    \n                    LaunchedEffect(viewModel, eventHandler) {\n                        viewModel.attachEventHandler(\n                            this,\n                            eventHandler.create(this, findNavController())\n                        )\n                        viewModel.trySend(ExampleContract.Inputs.Initialize)\n                    }\n                    \n                    ExampleContent(uiState) {\n                        viewModel.trySend(it)\n                    }\n                }\n            }\n        }\n    }\n\n    @Composable\n    fun ExampleContent(\n        uiState: ExampleContract.State = ExampleContract.State(),\n        postInput: (ExampleContract.Inputs) -&gt; Unit = {},\n    ) {\n        // ...\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "ios": {
            "ownKey": "ios",
            "ownPages": [{
              "reference": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "ios",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/ios"
              },
              "next": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "compose-desktop",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/compose-desktop"
              },
              "previous": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "android",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/android"
              },
              "description": "",
              "title": "iOS",
              "content": "<h1 id=\"ios\"><a href=\"#ios\" id=\"ios\" class=\"anchor\"><\/a>iOS<\/h1>\n<p>Ballast can be used from SwiftUI, but it requires a bit of boilerplate to be added to your iOS Swift code. The ViewModel\nimplementation needed for iOS is <code>IosViewModel<\/code>.<\/p>\n<article class=\"message is-info\">\n\n  <div class=\"message-body\">\n  <p>The following instructions for integrating Ballast into Swift are largely taken from Touchlab's wonderful\n<a href=\"https://github.com/touchlab/KaMPKit\">KaMPKit project<\/a>. The KaMPKit repo has been forked, and its Repository and ViewModel layers replaced with Ballast\nin the <a href=\"https://github.com/copper-leaf/KaMPKit-ballast\">copper-leaf fork<\/a> to show example usage of Ballast in iOS, rather than the custom equivalents used in the\nstandard project.<\/p>\n  <\/div>\n<\/article>\n<h2 id=\"initial-setup-one-time\"><a href=\"#initial-setup-one-time\" id=\"initial-setup-one-time\" class=\"anchor\"><\/a>Initial Setup (one-time)<\/h2>\n<p>Ballast can only be used in iOS with the new Kotlin/Native memory model. Start by making sure your project targets\nthe new memory model with <a href=\"https://github.com/JetBrains/kotlin/blob/master/kotlin-native/NEW_MM.md#enable-the-new-mm\">these instructions<\/a>. You will also need to make sure you declare an explicit dependency on\n<code>kotlinx-coroutines-core<\/code> version <code>1.6.0<\/code> or greater, because Ballast is compiled against coroutines 1.5.3, currently.<\/p>\n<pre><code class=\"language-kotlin\">val commonMain by getting {\n    dependencies {\n        implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0&quot;)\n    }\n}\n<\/code><\/pre>\n<p>Next, you'll need to create a Swift file in your iOS project to hold some Swift classes that wraps the Ballast ViewModel\nand converts its StateFlow into a Combine Publisher. You really don't need to understand what's in this file, you'll\nonly need to create it once. Copy <a href=\"https://github.com/copper-leaf/KaMPKit-ballast/blob/main/ios/KaMPKitiOS/CombineAdapters.swift\">this file<\/a> from the Ballast KaMPKit repo to your iOS Swift sources to add the\nnecessary boilerplate which connects Kotlin's Flows and Ballast's ViewModels to Swift's Combine framework, so that it\ncan be accessed properly from SwiftUI.<\/p>\n<p>Finally, you will also need to configure your Gradle scripts to <a href=\"https://kotlinlang.org/docs/multiplatform-build-native-binaries.html#export-dependencies-to-binaries\">export the Ballast dependencies<\/a> that need to be\nused from Swift code. You will need to export <code>ballast-core<\/code>, and probably <code>ballast-repository<\/code> if you're using that\nmodule. The dependencies you export will also need to be declared as an <code>api<\/code> dependency, not <code>implementation<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">kotlin {\n    ios()\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                api(&quot;io.github.copper-leaf:ballast-core:2.1.0&quot;)\n                api(&quot;io.github.copper-leaf:ballast-repository:2.1.0&quot;)\n                implementation(&quot;io.github.copper-leaf:ballast-saved-state:2.1.0&quot;)\n            }\n        }\n    }\n\n    cocoapods {\n        framework {\n            isStatic = false // SwiftUI preview requires dynamic framework\n            export(&quot;io.github.copper-leaf:ballast-core:2.1.0&quot;)\n            export(&quot;io.github.copper-leaf:ballast-repository:2.1.0&quot;)\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"using-ballast-from-swiftui\"><a href=\"#using-ballast-from-swiftui\" id=\"using-ballast-from-swiftui\" class=\"anchor\"><\/a>Using Ballast from SwiftUI<\/h2>\n<p>Then, from any SwiftUI View, you can observe one of your <code>IosViewModels<\/code> by wrapping it in <code>BallastObservable<\/code>. You'll\nneed to manually connect the <code>BallastObservable<\/code> to the SwiftUI View's lifecycle by calling\n<code>.activate()<\/code>/<code>.deactivate()<\/code> on the View's <code>.onAppear { }<\/code>/<code>.onDisappear { }<\/code> callbacks. One-time initialization should\nalso be placed in <code>.onAppear()<\/code>.<\/p>\n<p>Just like with Jetpack Compose, you should have a separate <code>*Content<\/code> View that has no direct knowledge of the Ballast\nViewModel. You'll pass in the observable's <code>vmState<\/code> and a callback function for <code>postInput<\/code> from the screen that\ncontains the ViewModel and manages its lifecycle. The <code>*Content<\/code> View, then, only needs to be responsible for displaying\nits content from the non-null <code>vmState<\/code> value, and passing Inputs through <code>postInput<\/code> to be processed by the Ballst\nViewModel. Note that Kotlin's Swift name translation will convert the nested class names like\n<code>ExampleContract.Inputs.Initialize<\/code> to drop the second <code>.<\/code> (looking like <code>ExampleContract.InputsInitialize<\/code> when created\nin Swift), and will also require you to provide labels for the parameters for all Inputs.<\/p>\n<pre><code class=\"language-swift\">import Combine\nimport SwiftUI\nimport shared\n\nstruct ExampleScreen: View {\n\n    @ObservedObject var vm = BallastObservable&lt;\n        ExampleContract.Inputs,\n        ExampleContract.Events,\n        ExampleContract.State&gt;(\n            viewModelFactory: { ExampleViewModel() }, // create directly or pass it in via DI\n            eventHandlerFactory: { ExampleEventHandler() } // optional, create directly or pass it in via DI\n    )\n\n    var body: some View {\n        ExampleContent(\n            vmState: observableModel.vmState,\n            postInput: observableModel.postInput\n        )\n        .onAppear(perform: {\n            observableModel.activate()\n            observableModel.postInput(ExampleContract.InputsInitialize())\n        })\n        .onDisappear(perform: {\n            observableModel.deactivate()\n        })\n    }\n}\n\nstruct ExampleContent: View {\n    var vmState: ExampleContract.State\n    var postInput: (ExampleContract.Inputs) -&gt; Void\n\n    var body: some View {\n        // ...\n    }\n}\n<\/code><\/pre>\n<p>Since the syntax for appear/disappear will be so common in a Ballast MVI project, the <a href=\"https://github.com/copper-leaf/KaMPKit-ballast/blob/main/ios/KaMPKitiOS/CombineAdapters.swift\">CombineAdapters.swift file<\/a>\nincludes a <code>.withViewModel<\/code> View extension to reduce the boilerplate a bit<\/p>\n<pre><code class=\"language-swift\">var body: some View {\n    ExampleContent(\n        vmState: observableModel.vmState,\n        postInput: observableModel.postInput\n    )\n    .withViewModel(observableModel) {\n        observableModel.activate()\n        observableModel.postInput(ExampleContract.InputsInitialize())\n    }\n}\n<\/code><\/pre>\n"
            }]
          },
          "compose-web": {
            "ownKey": "compose-web",
            "ownPages": [{
              "reference": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "compose-web",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/compose-web"
              },
              "next": {
                "path": "wiki",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "modules",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/modules"
              },
              "previous": {
                "path": "wiki/platforms",
                "baseUrl": "https://copper-leaf.github.io/ballast",
                "fileName": "compose-desktop",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://copper-leaf.github.io/ballast/wiki/platforms/compose-desktop"
              },
              "description": "",
              "title": "Compose Web (JS)",
              "content": "<h1 id=\"compose-web-js\"><a href=\"#compose-web-js\" id=\"compose-web-js\" class=\"anchor\"><\/a>Compose Web (JS)<\/h1>\n<p>There is no special support needed to use Ballast in <a href=\"https://compose-web.ui.pages.jetbrains.team/\">Compose Web<\/a> or other <a href=\"https://kotlinlang.org/docs/js-overview.html\">Kotlin/JS<\/a> applications. You will use\nthe <code>BasicViewModel<\/code> as your ViewModel implementation, and connect it to a custom <code>CoroutineScope<\/code> to control its\nlifecycle.<\/p>\n<p>All <a href=\"https://copper-leaf.github.io/ballast/wiki/examples\">Examples<\/a> are using Ballast in Kotlin/JS, so you can get a feel for what you can do with Ballast\nwithout leaving your browser.<\/p>\n<h2 id=\"example\"><a href=\"#example\" id=\"example\" class=\"anchor\"><\/a>Example<\/h2>\n<pre><code class=\"language-kotlin\">fun main() {\n    renderComposable(root = &quot;root&quot;) {\n        val applicationCoroutineScope = rememberCoroutineScope()\n        val viewModel = remember(applicationCoroutineScope) { ExampleViewModel(applicationCoroutineScope) }\n        val uiState by viewModel.observeStates().collectAsState()\n        Content(uiState) {\n            viewModel.trySend(it)\n        }\n    }\n}\n\n@Composable\nfun ExampleContent(\n    uiState: ExampleContract.State = ExampleContract.State(),\n    postInput: (ExampleContract.Inputs) -&gt; Unit = {},\n) {\n    // ...\n}\n<\/code><\/pre>\n"
            }]
          }
        },
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "platforms",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/platforms"
          },
          "next": {
            "path": "wiki/platforms",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "android",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/platforms/android"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/ballast",
            "fileName": "usage-guide",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/ballast/wiki/usage-guide"
          },
          "description": "",
          "title": "Platforms",
          "content": "<h1 id=\"platforms\"><a href=\"#platforms\" id=\"platforms\" class=\"anchor\"><\/a>Platforms<\/h1>\n<p>Ballast was intentionally designed to not be tied directly to any particular platform or UI toolkit. In fact, while most\nKotlin MVI libraries were initially developed for Android and show many artifacts of that initial base, Ballast started\nas a State Management solution for Compose Desktop and intentionally avoids any terminology or APIs that are really only\nuseful as an Android feature. Anything build for Ballast is expected to work on all platforms, with the exception of\nintegration with platform-specific SDKs such as <a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase\">Ballast Firebase<\/a>.<\/p>\n<p>Because Ballast was initially designed entirely in a non-Android context, it should work in any Kotlin target or\nplatform as long as it works with Coroutines and Flows. However, the following targets are officially supported, in\nthat they have been tested and are known to work there, or have specific features for that platform<\/p>\n<ul>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/android\">Android<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/ios\">iOS<\/a> (requires new Kotlin Native Memory Model)<\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/compose-desktop\">Compose Desktop (JVM)<\/a><\/li>\n<li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/compose-web\">Compose Web (JS)<\/a><\/li>\n<\/ul>\n"
        }]
      }
    },
    "ownPages": [{
      "reference": {
        "path": "",
        "baseUrl": "https://copper-leaf.github.io/ballast",
        "fileName": "wiki",
        "extension": "html",
        "usePrettyUrl": true,
        "link": "https://copper-leaf.github.io/ballast/wiki"
      },
      "description": "",
      "title": "Wiki",
      "content": "<html>\n <head><\/head>\n <body>\n  <ul> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/feature-overview\">Features<\/a><\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/mental-model\">Thinking in Ballast MVI<\/a><\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/usage-guide\">Usage Guide<\/a><\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms\">Platforms<\/a> \n    <ul> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/android\">Android<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/ios\">iOS<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/compose-desktop\">Compose Desktop (JVM)<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/platforms/compose-web\">Compose Web (JS)<\/a><\/li> \n    <\/ul> <\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules\">Modules<\/a> \n    <ul> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-core\">Ballast Core<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-saved-state\">Ballast Saved State<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-repository\">Ballast Repository<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-firebase\">Ballast Firebase<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-debugger\">Ballast Debugger<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-intellij-plugin\">Ballast Intellij Plugin<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/modules/ballast-test\">Ballast Test<\/a><\/li> \n    <\/ul> <\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples\">Examples<\/a> \n    <ul> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/counter\">Simple Counter<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/scorekeeper\">Scorekeeper<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/bgg-api\">API Call and Cache<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/kitchensink\">Kitchen Sink<\/a><\/li> \n     <li><a href=\"https://copper-leaf.github.io/ballast/wiki/examples/kamp-kit\">KaMPKit<\/a><\/li> \n    <\/ul> <\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/feature-comparison\">Feature Comparison<\/a><\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/roadmap\">Roadmap<\/a><\/li> \n   <li><a href=\"https://copper-leaf.github.io/ballast/wiki/changelog\">Changelog<\/a><\/li> \n  <\/ul> \n <\/body>\n<\/html>\n"
    }]
  }}
}